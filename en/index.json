[
{
	"uri": "https://safersys.github.io/mm/en/sys-sec/attacks/data-op/2015-ccs-jujutsu/",
	"title": "Jujutsu",
	"tags": [],
	"description": "",
	"content": " References:\n[1] Control Jujutsu: On the Weaknesses of Fine-Grained Control Flow Integrity. CCS, 2015.\nA new attack on fine-grained CF that exploit the incompleteness of pointer analysis, when combined with common software engineering practices, to enable an attacker to execute arbitrary malicious code.\nConcepts:  ICS: Indirect Call Site ACICS: Argument Corruptible Indirect Call Site RCE: Remote Code Execution DSA: Data Structure Analysis DEP: Data Execution Prevention ASLR: Address Space Layout Randomization SSP: Stack Smashing Protection ROP: Return-oriented Programming JOP: Jump-Oriented Programming  Threat Model The threat model in this paper is a remote attacker trying to hijack control of a machine by exploiting memory vulnerabilities.\nSecure Part:\n Fine-grained CFI, with unlimited tags for the forward edge and a shadow stack DEP deployed. ASLR deployed.  Insecure Part:\n Memory corruption vulnerability exits, which allows an attacker to corrupt certain values on stack or heap.  Exploit Design Searching ACICS Candidate Searching among all ICS:\n The forward edge pointer and its arguments that reside on the heap or a global variable. The argument at ICS can be altered without crashing the program, before reaching a target function. The ICS should be reachable from external input, e.g., a network request.  ap_run_dirwalk_stat() contains pHook[n].pFunc, which invokes a function pointer.\nSelect Target piped_log_spawn\nExploit  use heap memory corruption vulnerability to corrupt an entry in the _hooks structure\u0026rsquo;s link_dirwalk_stat field to point to piped_log_spawn.\n use same vulnerability to corrupt the struct in the request_rec-\u0026gt;finfo field such that, when viewed as a piped_log struct, the fields read_fd and write_fd are null, and the field program points to a string with the name and arguments of the program we intend to invoke, such as /bin/sh -c ....\n  Why success with fine-grained CFI? Short answer: No fine-grained CFI with CFG generated by static analysis.\nLong story:\nBuilding control flow graph with static analysis  A precise CFG requires a pointer analysis to determine the set of functions to which the pointer at each indirect call site can point.\n Challenges\n Global Struct. _hooks is a global struct variable in Apache HTTPD. Each filed of it contains an array of function pointers. For example, field link_dirwalk_stat contains an array of function pointers to implementation functions of the functionality dirwalk_stat. Customized Container API to manipulate function pointers. The analysis has to capture inter-procedural data flows via customized container APIs. For example, function pointers are stored and manipulated using customized array APIs apr_array_push(), apr_array_make(). Macro Generated Code. Those code are structurally similar. This imposes a significant additional precision requirement on the static analysis, as it needs to consider a (potentially) large number of similar functions that can manipulate the data structures inside _hooks.  Static Analysis Trade-offs\nPrecise(sound and complete) pointer analysis is undecidable[41], for languages with if statements, loops, dynamic storage, and recursive data structures.\nQuestions: Could we restrict the language features in different ways so that the pointer analysis could either be sound, or complete, or decidable? "
},
{
	"uri": "https://safersys.github.io/mm/en/mem-safe/embed/usfi/",
	"title": "Usfi",
	"tags": [],
	"description": "",
	"content": "uSFI1.\n  Ultra-lightweight software fault isolation for iot-class devices. DATE, 2018. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/mem-safe/embed/minion/",
	"title": "Minion",
	"tags": [],
	"description": "",
	"content": "Reference:\n "
},
{
	"uri": "https://safersys.github.io/mm/en/mem-safe/embed/",
	"title": "Embed",
	"tags": [],
	"description": "",
	"content": "Reference:\n Usfi  uSFI1. Ultra-lightweight software fault isolation for iot-class devices. DATE, 2018. ↩  Minion  Reference:  nesCheck  nesCheck1. Statically find all provable memory bugs and report them as errors; Statically find all potentially unsafe memory accesses, determine and exclude those that will never result in a memory corruption in a conservative way; report the remaining vulnerabilities as warnings; Dynamically instrument all remaining vulnerable location with runtime checks, and catch all memory errors at runtime. Related text with sil: Similar to CCured, nesCheck leverages more extensive static analysis and tailored runtime checks for wireless sensor network system (TinyOS)\n uXOM  $\\mu$XOM1: Efficient eXecute-Only Memory on ARM Cortex-M. USENIX Security, 2019. Background Code injection attacks: W$\\oplus$X. Since virtually all processors today are equipped with at least five basic memory permissions: read-write-execute (RWX), read-write (RW), read-execute (RX), read-only (RO) and no-access (NA). W$\\oplus$X can be efficiently enforced in hardware for a memory region solely by disabling RWX. Disclosure attacks: attemps to read part of or possibly the entire code. Code often contains intellectual properties (IPs) including core algorithems and sensitive data like cryptographic keys.\n "
},
{
	"uri": "https://safersys.github.io/mm/en/langs/nesc/",
	"title": "NesC",
	"tags": [],
	"description": "",
	"content": "Reference:\n "
},
{
	"uri": "https://safersys.github.io/mm/en/mem-safe/embed/nescheck/",
	"title": "nesCheck",
	"tags": [],
	"description": "",
	"content": " nesCheck1.\n Statically find all provable memory bugs and report them as errors; Statically find all potentially unsafe memory accesses, determine and exclude those that will never result in a memory corruption in a conservative way; report the remaining vulnerabilities as warnings; Dynamically instrument all remaining vulnerable location with runtime checks, and catch all memory errors at runtime.  Related text with sil:\nSimilar to CCured, nesCheck leverages more extensive static analysis and tailored runtime checks for wireless sensor network system (TinyOS)\nStatic Analysis   nesCheck. AsiaCCS, 2017. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/research/paperwriting/",
	"title": "Paper Writing",
	"tags": [],
	"description": "",
	"content": "Excellent Sampes:\nPortable Native Client @ USENIX Security 20101\n  Adapting Software Fault Isolation to Contemporary CPU Architectures. USENIX SEC, 2010. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/mem-safe/nacl/pnacl/",
	"title": "Portable NaCl",
	"tags": [],
	"description": "",
	"content": " Portable Native Client 1: control flow and memory integrity with average performance overhead of under 5% on ARM and 7% on x86-64.\nIntroduction About previous SFI on CISC Control+store SFI on x86-32, which we considered excessive, indicates about 25% overhead.\n \u0026ldquo;As we continued our exploration of ARM SFI and sought to understand ARM behavior relative to x86 behavior, we could not adequately explain the observed performance gap between ARM SFI at under 10% overhead with the overhead on x86-32 in terms of instruction set differences. With further study we understood that the prior implementations for x86-32 may have suffered from suboptimal instruction selection and overly pessimistic alignment.\u0026rdquo;\n ARM ISA and binary format On ARM, only 16-bit Thumb and 32-bit ARM instructions.\nARM binaries commonly include a number of read-only data embedded in the text segment. Such data in executable memory regions must be isolated to ensure it cannot be used to invoke system call instructions or other instructions incompatible with our sandboxing scheme.\nIndirect control flow and memory reference Indirect control flow and memory references must be constrained to within the untrusted memory region, achieved through sandboxing instructions.\nPage protection to replace segmentation (considered, but not used) Page-table protection would be used to prevent the untrusted code from manipulating trusted data; SFI is still required to enforce control flow instructions.\nHence, page protection only avoids data SFI; the control flow SFI persists.\nBut depends on OS-based protection mechanisom. This OS interaction is complicated y the requirement for multiple threads that transition independently between untrusted and trusted execution.\nHigh complexity and overhead, with small potential performance gain ==\u0026gt; Not suitable.\nArch Design  All use alignment masks on control flow target addresses;\n on ARM/x86-64, use high-order address bits to limit control flow targets to logical zero-based virtual address range;   Data mask\n No data mask on x86-32; use segmentation instead; ARM/x86-64: combining masking and guard pages to keep stores within the valid address range for untrusted data. Can read outside of sandbox. Explicit instruction data mask for ARM: Implicit in result width on x86-64:  Data type: ILP32\n Int, Long, Pointer are all 32 bit. same as x86-32, for portability between systems. can improve performance on x86-64 systems.  Instruction sequences\n Address space layout\n  Impl on ARM ARM designs:\n condition codes that can be used to predicate most instructions. ??? what is the predicate mean here?  ARM goals:\n No forbidden instructions in untrusted code; No store above 1GB in untrusted code; No jump above 1GB in untrusted code.  Extension to Wahbe et al. 2\n reserve no registers for holding sandboxed addresses; instead requiring they are computed and checked in a single instruction: ``; ensure integrity of multi-instruction sandboxing by ???, with adaption to further prevent execution of embeded data; ARM\u0026rsquo;s fully predicated instruction set to introduce an alternative data address sandboxing sequence: replace a data dependency with control dependency, preventing pipeline stalls and providing better overhead on multiple-issue and out-of-order microarchitectures. ??? why  Code layout: 16 bytes bundles/four instrs; All ARM instructions, no Thumb; data bundles starting with invalid offset to prevent execution as code.\nValidation:\n direct branch: confirms the target is a valid instruction (bundle start); indirect branch: forbide writing to r15, the PC; only allow explicit branch instruction, such as bx, r0 and their conditional equivalents; most significant 2 bits cleared; 4 least significant bits cleared;  bic r0, r0, #0xc000,000f bx r0 /* # pop {pc} is replaced with */ pop {lr} bic lr, lr, 0xc000,000f bx lr Note above code: data dependency between bx branch and masking instruction. This pattern(generating an address via the ALU and immediately jumping to it) is sufficiently common in ARM code that the modern ARM implementations[^3] can dispatch the sequence without stalling.\nData Stores: check within 1 GB.\ntst r0, #0xc0000000 streq r1, [r0, #12] ==\u0026gt; use tst rather than bic here avoids a data dependency between the guard instruction and the store, eliminating a two-cycle address-generation stall on Cortex-A8 that would otherwise triple the cost of the added instruction.\n(Again this is ARM\u0026rsquo;s fully predicated instruction set).\nGuard page: immediate displacement: $\\pm$ 4096 bytes (only base-plus-displacement addressing is allowed, forbide multiple registers), can be used to overflow/underflow 1GB by 4096 bytes; use guard page to trap such.\nStack SP: within 1 GB.\nLLVM 2.6 for ARM; faster than GCC.\nImpl on x86-64 x86-64 features:\n 8 new general purpose registers: r8 - r15.  Rules:\n 4 GB aligned region; flanked above/below by 10 x 4GB regions. ??? why 10?    Take aways   Adapting Software Fault Isolation to Contemporary CPU Architectures. USENIX SEC, 2010. ↩ Efficient software-based fault isolation. By R. Wahbe, S. Lucco, T.E. Anderson, and S.L. Graham. ACM SIGOPS Operating System Review. 1993. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/practice/msinterview/",
	"title": "编程之美",
	"tags": [],
	"description": "",
	"content": "《编程之美》1\n一句话：关键不在于答案，而在于思考问题的方法。\n知己知彼：了解公司的文化、战略方向。\n笔试是基础，需要扎实的理解和考虑完备的解答。\n面试是探讨，需要缜密的代码和严密的分析赢得未来同事的尊重。思考问题的方法比最终的答案重要，面试者会更加在乎你解决问题的思考过程。\n通过自己实际的工作和产品来体现自己的水平。\n  《编程之美》，2008。 ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/sys-sec/defences/tamper-resistance/",
	"title": "Tamper Resistant Software Design and Implementation: IVK",
	"tags": [],
	"description": "",
	"content": "Paper1: Make software immune to observation and modification.\nTamper-resistance using Integrity Verification Kernels:\n segments of code which are self-modifying, self-decrypting and installation unique. code segments communicates with other such code, creating an interlocking trust model.  Threats:\n breach communication access controls to attack the system;\n computer virus;\n attacker as insider: may modify at will.\n    Tamper Resistant Software Design and Implementation. 1999. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/sys-sec/detection/prima/",
	"title": "Prima",
	"tags": [],
	"description": "",
	"content": "PRIMA1: Info flow attestation.\n an extension to Linux IMA:\n measures the code (Linux IMA), and measures which information are present among processes.  attest Biba and Clark-Wilson2, CW-Lite3; CW-Lite attestation is proved.\n Implementation: on SELinux.\n  Info flow examples:\nBiba integrity requires that a process receive no input that is lower integrity than itself4.\nLOMAC(Low-Water Mark Integrity) requires that a process\u0026rsquo;s integrity be that of the lowest integrity input that it receives5.\nCW-Lite guarantee is same as Clark-Wilson: all flows from untrusted processes to high integrity ones must pass through a filtering/sanitizing procedure in the destination process.\nLinux IMA   PRIMA: Policy-Reduced Integrity Measurement Architecture. SACMAT, 2006. ↩ A comparison of commercial and military computer security policies. SP, 1987. ↩ Toward automated information flow integirty for security critical applications. NDSS. 2006. ↩ K. J. Biba. Integrity considerations for secure compter systems. MITRE MTR-3153. 1975. ↩ Lomac: Low water-mark integrity protection for cots environments. SP, Washington, DC, 2000. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/sys-sec/defences/info-flow/",
	"title": "Info Flow Integrity",
	"tags": [],
	"description": "",
	"content": "Reference:\n "
},
{
	"uri": "https://safersys.github.io/mm/en/sys-sec/detection/flicker/",
	"title": "Flicker",
	"tags": [],
	"description": "",
	"content": "Flicker1:\n 250 lines of code trusted; No trust on BIOS, OS, DMA devices. Trust processor (AMD/Intel) Fine-grained Attestation:\n e.g. A piece of server code handling the client password; no trust on all other softare stack from BIOS to OS. e.g. A Certificate Authority (CA) could sign certificates with its pricate key, even while keeping the key secret from a malicious BIOS/OS/DMA-enabled devices.  Use of Flicker can be attested.\n Executed code, its input and output, can be attested.\n  Processor Features:\n Late launch and attestation    Flicker: An execution Infrastructure for TCB minimization. EUROSYS, 2008. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/sys-sec/detection/verifyexe/",
	"title": "Verifiable Code Execution",
	"tags": [],
	"description": "",
	"content": "Pioneer1\nUntrusted computing platform can tamper with code execution in at least three ways:\n By modifying the code before invoking it; Executing alternate code; or modifying execution state such as memory or registers when the code is running.  Pioneer: challenge-response protocole between trusted \u0026amp; untrusted platform.\nAssuarance that:\n an arbitrary piece of code (the executable) on the untrusted platform is unmodified; the unmodified executable is invoked for execution on the untrusted platform; The exectable is executed untampered, despite the presence of malicious software on the untrusted platform.    Pioneer: Verifying Code Integrity and Enforcing Untampered Code Execution on Legacy Systems. SOSP, 2005. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/mem-safe/nacl/",
	"title": "Google Native Client Sandboxing",
	"tags": [],
	"description": "",
	"content": " Reference: NaCl1, PNaCl2\nOriginal NaCl Inner sandbox, the NaCl module:\n code section is read-only and statically linked; code section is conceptually divided into fixed sized bundles of 32 bytes. All valid instructions are reachable by a dissassembly starting at a bundle beginning. All indirect control flow instructions are replaced by a multiple-instruction sequence (pseudo-instruction) that ensures target address alignment to a bundle boundary. No instructions or pseudo-instrucitons in the binary crosses a bundle boundary.\n All rules above are checked by a verifier brefore a program is executed. This verifier with the runtime system comprise NaCl\u0026rsquo;s trusted computing base (TCB).\n  Outer sandbox: system call interposition\n mediates system calls at the process boundary; similar to prior stuctures: systrace3 and Janus 4.  Thread model of original NaCl  code for untrusted module: confirms to validity rules, reject otherwise. NaCl module may  execute any reachable instruction block in the validated text segment; \u0026ndash;\u0026gt; weak control flow exercise the NaCl ABI to access runtime servies in any way: passing invalid arguments, etc. send arbitrary data via our intermodule communication interface; allocate memory and spawn threads up to resource limits. ??? how to limit the resource of a sandbox?   (From Chapter 2, page 3) Native Client is ideal for application components requiring pure computation. It is not appropriate for modules requiring process creation, direct file system access, or unrestricted access to the network.\nInterfaces of NaCl to communicate outside of sandbox  Inter-Module Communications (IMC) for general inter-component communication;used by both trusted and untrusted components, such as the trusted JavaScript components, NaCl browser plugin, and untrusted NaCl modules.\n send/receiving datagrams, contains: untyped arrays, along with optional: NaCl Resource Descriptors for sharing of files, shared memory objects, communication channels, etc.  Communicate between Browser and NaCl module:\n Simple RPC facility (SRPC) Netscap Plugin Application Programming Interface (NPAPI) Both based on IMC  \u0026ldquo;service runtime\u0026rdquo; and NaCl module:\n memory management operations; thread creation; other system services. sysbrk(), mmap(), malloc()/free() Analogous to the system call interface of a conventional OS. System call interception.   Attack surface  Inner sandbox: binary validation Outer sandbox: OS system-call interception Service runtime binary module loader Service runtime trampoline interfaces IMC communication interface NPAPI interface  (From 2.3, page 4): In addition to the inner and outer sandbox, the system design also incorporates CPU blacklist and NaCl module blacklist. ==\u0026gt; ??? What is the CPU black-list, NaCl black-lists????\nNaCl dev environment  Linux based GCC 4.2.2  Related work Native Client applies concepts of software isolation and proof-carrying code that have been extensively discussed in the research literature.\n NaCl data integrity scheme is a straightforward application of segmented memory as implemented in the Intel 80386.\n NaCl control flow integrity technique builds on the seminal work by Wahbe, Lucco, Anderson and Graham5. Native Client extends this previous work with specific mechanisms to achieve safety for the x86 ring-3 instruction set archtecture, using several techniques first described by McCamant and Morrisett6.\n NaCl uses a static validator rather than a trusted compiler, similar to validators described for other systems 6 7 8 9, applying the concept of proof-carrying code10.\n  Compare with CFI11:\n CFI: finer-grained control flow integrity. NaCl: only guarantees indirect control flow will target an aligned address in the text; Finer-grained CFI is not useful for Native Client:\n NaCl intends to permit quite arbitrary control flow, even hand-coded assembler, as long as execution remains in known text and targets are aligned.  CFI 15% on SPEC 2000. Three times higher than NaCl 5%.\n XFI 9 add data dandboxing to CFI control flow checks. with additioinal overhead; NaCl get data integrity for free from x86 segments\n  NaCl descriptors similar mechanisms:\n EROS [^55] capabilities. Singularity [^30] channel. DTrace[^11], Systemtap8, XFI9.   Portable NaCl  Portable Native Client 1: control flow and memory integrity with average performance overhead of under 5% on ARM and 7% on x86-64. Introduction About previous SFI on CISC Control+store SFI on x86-32, which we considered excessive, indicates about 25% overhead. \u0026ldquo;As we continued our exploration of ARM SFI and sought to understand ARM behavior relative to x86 behavior, we could not adequately explain the observed performance gap between ARM SFI at under 10% overhead with the overhead on x86-32 in terms of instruction set differences.\n  Native Client: A Sandbox for Portable, Untrusted x86 Native Code. SP 2009. ↩ Adapting Software Fault Isolation to Contemporary CPU Architectures. USENIX SEC, 2010. ↩ N. Provos. Improving host security with system call policies. USENIX Security, 2003. ↩ A secure environment for untrusted helper applications. USENIX Security, 1996. ↩ Efficient software-based fault isolation. By R. Wahbe, S. Lucco, T.E. Anderson, and S.L. Graham. ACM SIGOPS Operating System Review. 1993. ↩ Efficient, verifiable binary sandboxing for a CISC architecture. By S. McCamant and G. Morrisett. MIT-CSAIL-TR-2005-30, 2005. ↩ Evaluating SFI for a CISC architecture. By S. McCamant and G. Morrisett. USENIX Security, 2006. ↩ Locating system problems using dynamic instrumentation. Ottawa Linux Symposium, 2005. ↩ XFI: Software guards for system address spaces. OSDI, 2006. ↩ G. Necula. Proof carrying code. Principles of Programming Languages. 1997. ↩ Control flow integrity: Principles, implementations, and applications. By M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti. CCS, 2005. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/mem-safe/embed/uxom/",
	"title": "uXOM",
	"tags": [],
	"description": "",
	"content": " $\\mu$XOM1: Efficient eXecute-Only Memory on ARM Cortex-M. USENIX Security, 2019.\nBackground Code injection attacks: W$\\oplus$X. Since virtually all processors today are equipped with at least five basic memory permissions: read-write-execute (RWX), read-write (RW), read-execute (RX), read-only (RO) and no-access (NA). W$\\oplus$X can be efficiently enforced in hardware for a memory region solely by disabling RWX.\nDisclosure attacks: attemps to read part of or possibly the entire code. Code often contains intellectual properties (IPs) including core algorithems and sensitive data like cryptographic keys. Can also be abused to launch code reuse attacks (CRAs).\nXOM: eXecute-Only-Memory.\n By main memory encryption 2. By hardware permission bits (execute-only) in Exoshim 3, Norax 4, and KHide 5, Readactor6. XOM permission bits are generally available on servers, desktops, smartphones, but not available on embedded devices. SFI-based XOM 7 kr^x 8: performs not optimally; can be circumvented (by privileged app).  Embeded devices: Efficient eXecute-Only Memory on ARM Cortex-M. USENIX Security, 2019 - Applications and kernels operates on same privilege level: - real-time constraints: mode switching is expensive 9\nKey Idea $\\mu$XOM converts all memory instructions into unprivileged ones and sets the code region as privileged. As a result, converted instructions cannot access code regions, thereby effectively enforcing the XO permission onto code regions.\nChallenges/Solutions  some memory instructions cannot be changed into uprivileged memory instructions. E.g. those access critical system resources, interrupt controller, timer, MPU, etc.\n load/store exclusive instructions do not have unprivileged conterparts. $\\mu$XOM: analyze the code to exclude them from instrumentation.\n unconverted instructions can be exploited. Can be used to\n turn off the MPU; reading code directly.  unconverted instructions in $\\mu$XOM are instrumented with verification routines:\n does not break XOM; atomic verification: virtually enables memory instructions to be executed atomically with verification routine.  ??? how   alter control flow to execute unintended/unaligned/data-derived instructions in code region[^usfi]. ==\u0026gt; uXOM: replace danger sequence with secure equivalent.\n e.g. ???   Evaluation LLVM compiler; Radare2 binary analysis framework10\n   Solution code size exe time energy     uXOM 15.7% 7.3% 7.5%   SFI-XOM 50.8% 22.7% 22.3%   uXOM-CRA 19.3% 8.6% 9.7%      $\\mu$XOM: Efficient eXecute-Only Memory on ARM Cortex-M. USENIX Security, 2019. ↩ David Lie, Chandramohan Thekkath, Mark Mitchell, Patrick Lincoln, Dan Boneh, John Mitchell, and Mark Horowitz. Architectural support for copy and tamper resistant software. ACM SIGPLAN Notices, 2000. ↩ Exoshim: Preventing memory disclosure using execute-only kernel code. Cyber Warfare and Security. 2016. ↩ Norax: Enabling execute-only memory for cots binaries on aarch64. SP, 2017. ↩ Preventing kernel code-reuse attacks through disclosure resistant code diversification. CNS, 2016. ↩ Readactor: Practical code randomization resilient to memory disclosure. SP, 2015. ↩ Leakage-resilient layout randomization for mobile devices. In NDSS, 2016. ↩ kr^x: Comprehensive kernel protection against just-in-time code reuse. CCS, 2017. ↩ Securing real-time microcontroller systems through customized memory view switching. In NDSS, 2018. ↩ unix-like reverse engineering framework and commandline tools. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/sys-sec/attacks/pe/",
	"title": "Privilege Escalation",
	"tags": [],
	"description": "",
	"content": "Reference:\n "
},
{
	"uri": "https://safersys.github.io/mm/en/compilers/backend/",
	"title": "Backend",
	"tags": [],
	"description": "",
	"content": " Reference: Tutorial: Creating an LLVM Backend for the Cpu0 Architecture\nMIPS call  "
},
{
	"uri": "https://safersys.github.io/mm/en/langs/go/setup/",
	"title": "Setup",
	"tags": [],
	"description": "",
	"content": " Environment Variables Reference:\nGOPATH: environment variable that specifies the location of your workspace. If no GOPATH is set, it is assumed to be $HOME/go on Unix systems and %USERPROFILE%\\go on Windows. more\nBinary Package Download\nGetting Started with Go\nBuild from Source Install Go from Source\nUninstalling Go  delete go directory. usually /usr/local/go under Unix or c:\\Go on Windows. remove Go bin directory from the $PATH environment variable. usually /etc/profile, or $HOME/.profile on Linux/FreeBSD; /etc/paths.d/go on MacOS; or Windows environment variable settings.   "
},
{
	"uri": "https://safersys.github.io/mm/en/os/l4/",
	"title": "L4",
	"tags": [],
	"description": "",
	"content": "Reference:\nL4 kernel projects\nseL4: from Data61\nOKL4: from Open Kernel Lab\n "
},
{
	"uri": "https://safersys.github.io/mm/en/pri-sep/2019privana/",
	"title": "PrivAnalyzer: Measuring the Efficacy of Linux Privilege Use",
	"tags": [],
	"description": "",
	"content": "Reference: 2019 PrivAnalyzer1\n PrivAnalyzer: Measuring the Efficacy of Linux Privilege Use. DSN, 2019 ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/langs/aop/",
	"title": "Aspect Oriented Programming",
	"tags": [],
	"description": "",
	"content": "Reference: what is aop\n "
},
{
	"uri": "https://safersys.github.io/mm/en/pri-sep/2017enclave/",
	"title": "Glamdring: Automatic Application Partitioning for Intel SGX",
	"tags": [],
	"description": "",
	"content": "Reference: Glamdring @ 2017ATC 1\n  Glamdring: Automatic Application Partitioning for Intel SGX. USENIX ATC, 2017. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/pri-sep/2007web/",
	"title": "Secure web applications via automatic partitioning",
	"tags": [],
	"description": "",
	"content": "Reference: Secure web @ 2007SOSP1.\n  Secure web applications via automatic partitioning. SOSP, 2007. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/pri-sep/2004privtrans/",
	"title": "Privtrans: Automatically Partitioning Programs for Privilege Separation",
	"tags": [],
	"description": "",
	"content": " References:\nPrivtrans @ 2004SP1;\nPrivilege separation in OpenSSH2;\nPartition a single program into two parts:\n a monitor, relegated all trust an privileges; a small TCB; a slave.  Q \u0026amp; A  What kind of static analysis techniques are used?\n What kind of dynamic analysis techniques are used?\n How to determine bounds of domain?\n How to define the interfaces between domains?\n  Solution:  Programmer annotations. Indicates privileged operations using attributes.\n privileged variables/functions.  Inter-procedural static analysis.\n Propagates attributes locate privileged functions and data  C-to-C translation. Partition the input source code into two programs: the monitor and the slave.\n Data flow techniques to find proper place to insert calls to the monitor. Static + Dynamic analysis to reduce the number of expensive calls made by the slave to the monitor. inserts dynamic checks: to reduce overhead by limiting the number of expensive calls from the slave to monitor ?.  Monitor-slave interface\n two processes, isolated by OS. commumicate via inter-process or inter-network sockets. A base RPC library is provided, as wrappers for common privileged calls  Allow finer-grained policies than access control.\n policies defined by programmer; policies implemented in and enforced by monitor.   User Annotations and Policies Annotations: Two C type qualifier3:\n \u0026ldquo;priv\u0026rdquo;: mark a) variable initialized from privileged resource, will be in the monitor; b) privileged functions, will be in the monitor. \u0026ldquo;unpriv\u0026rdquo;: only used when downgrading a privileged variable.  Policies: A monitor policy. Specifies what operations the slave can ask the monitor to perform.\n written in monitor as C code; enforced since all privileged operations go through the monitor. some can be automatically generated: CFG -\u0026gt; Finite State Machine (FSM) model of possible privileged calls; Pushdown Automata (PDA)  FSM call policy: - remove edges that do not lead to privileged call; got a a collapsed FSM, a directed graph of valid privileged call sequences; - FSM saved to file; read by monitor during initialization. - Requests from slave are checked against the FSM: a call is allowed only if there is an edge from the proceeding call to the current call in the FSM.\nPDA to limit FSM:\n limit the number of allowable call sequences.  PDA related work to limit the call sequences: MOPS 4, malicious call stream detection5, CIL6, Enforceable security policies7, 1999SP 8, and Automatic extraction of OO interfaces9.\n???Easier to write more precise policy than system-call interposition: \u0026ldquo;In system call interposition, a model is needed for both privileged and unprivileged system calls. The policy in system call interposition is usually more complex as the number of system call increases. Privilege separation limites the number of privileged operations to only the interface exported by the monitor, which may reduce the complexity of the resulting policy.\u0026rdquo; ???\nDowngrading data: allow privileged data to flow from the monitor to the slave.\nExample: reading a file contain public/private key pair; file is privileged, private key is privileged, but public key can flow out.\nPrivtrans Analysis \u0026amp; Transformation Overview:\nAttribute propagation\nCall to the monitor: The slave calls privwrap: the interface provided for slave to call the monitor; 1) marshaling the arguments; 2)sending arguments, along with a vector describing the run-time privileged status of each variable, to the monitor; 3) waiting for the monitor to respond; 4) demarshaling any results; 5) return proper results to the slave;\nExecution and return to monitor: The monitor calls privunwrap : 1) demarshals the arguments received; 2) checks the policy to see if the call is allowed; 3) looks up any privileged actuals in its state store; 4) performs the function; 5) if result are marked as privileged, hashes the results to its state store and set the return value of the function to be the hash index; 6) marshals the return values and sends them back to the slave.\nStarting the monitor: priv_init as the first instruction in main. It can optionally\n fork off the monitor process and drop the privileges of the slave; or it contacts an running monitor. ???\n the slave waits for notification from the monitor about successful initialization.\n  Locating privileged data -\u0026gt; Use CIL6 to read in and transform the source code.\n-\u0026gt; Use interprocedural static analysis to locate all potentially privileged call sites.\n A standard meet-over-all-paths data-flow analysis: the priv attribute is added to a variable if it can be assigned to by another privileged variable over any path in the program. Inter-procedural analysis by iteratively adding the privileged attribute across defined functions. ??? since we do not have the function body for procedures declared but not defined, we assume that the privileged attribute could be added to any pointer argument, i.e., a pointer value could be a return value. (??? is this talking about the compatibility with library functions?) ??? If an atrribute is missing, the slave will attempt a call without appropriate privileges, and the call will fail. (??? what if the attribute is not propagated to privileged function, and that function got called by slave directly?)\n After propagation of attributes, we got a set of calls that potentially should be executed by the monitor.\n  -\u0026gt; Rewrites a call to f that may be privileged to the wrapper function privwrap_f. Then privwrap_f use RPC to ask the monitor to execution the f.\n-\u0026gt; Insert run-time checks to limit the number of calls from the slave to the monitor.\n static analysis is conservative, any call site that may be privileged is considered privileged; combined with run-time information, the number of privileged calls could be reduced.  -\u0026gt; privilege polymorphic functions: can somewhere/sometime be privileged, and somewhere/sometime not privileged.\n  Privtrans: Automatically Partitioning Programs for Privilege Separation. SP, 2004. ↩ Preventing Privilege Escalation. SP, 2003. ↩ Rationale for International Standard \u0026ndash; Programming Languages \u0026ndash; C. American National Standard Institutue(ANSI), Oct 1999. ↩ MOPS: an infrastructure for examining security properties of software. CCS, 2002. ↩ Detecting manipulated remote call streams. SP, 2002. ↩ CIL: Intermediate language and tools for analysis and transformation of C programs. CCC, 2002. ↩ Fred Schneider. Enforceable security policies. Information and System Security, 2000. ↩ R. Sekar P Uppuluri. Synthesizing fast intrusion prevention/detection systems from high-level specifications. SP, 1999. ↩ John Whaley, Michael Martin, and Monica Lam. Automatic extraction of object-oriented component interfaces. In the Proceedings of the International Symposium on Software Testing and Analysis, 2002. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/sva/safecode/runtimechecks/funcptrs/",
	"title": "Function Ptrs",
	"tags": [],
	"description": "",
	"content": " Reference: Enforcing Alias Analysis for Weakly Typed Languages, TR, 2005.\nRuntime Check on Function Pointers (From 2005 TR1) The call graph is simply checked explicity at each indirect call site ( some could be removed).\nCall graph is one of the input of SAFECode. The call graph is represented in the input type system by adding a function set attribute called $fs$ in Figure 2 to each function pointer type, making explicit the set of possible targets for that function pointer.\nThe function set attribute can be initialized using the $FSET$ definition. For example, the definition $FSET fs = func1, func2, func3;$ followed by a use $(int \\rightarrow int)*fs \\ \\ fptr;$ denotes a function pointer $fptr$ whose targets are the functions $func1, func2, func3$.\nOptimization Optimization by eliminate function pointer checks:\n Simple typing rules that can statically check the call graph contained in the pointer analysis in most cases;\n Add runtime checks where static checking is not possible;\n A more precise call graph by adding extra run-time checks only at call sites where more precision is required.\n  PAFSET attribute in addition to FSET attribute: - FSET: If two function pointers have the same FSET attribute, they potentially call the same set of functions. - PAFSET: To differentiate between the input call graph and the call graph given by the pointer analysis, use PAFSET to identify the function poiner from pointer analysis.\n Enforcing Alias Analysis for Weakly Typed Languages, TR, 2005. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/langs/go/",
	"title": "Go",
	"tags": [],
	"description": "",
	"content": "Reference:\nConcurrency\n Setup  Environment Variables Reference: GOPATH: environment variable that specifies the location of your workspace. If no GOPATH is set, it is assumed to be $HOME/go on Unix systems and %USERPROFILE%\\go on Windows. more Binary Package Download Getting Started with Go Build from Source Install Go from Source Uninstalling Go delete go directory. usually /usr/local/go under Unix or c:\\Go on Windows. remove Go bin directory from the $PATH environment variable. usually /etc/profile, or $HOME/.\n Tour  A Tour of Go Types basic types: bool; // false is zero (initial) value for bool string; // \u0026ldquo;\u0026rdquo; (the empty string) is zero (initial) value for string int, int8, int16, int32, int64 uint, uint8, uint16, uint32, uint64, uintptr byte // alias for uint8 rune // alias for int32, Unicode point float32, float64 complex64, complex128 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/cmplx\u0026#34; ) var ( ToBe bool = false MaxInt uint64 = 1\u0026lt;\u0026lt;64 - 1 z complex128 = cmplx.\n "
},
{
	"uri": "https://safersys.github.io/mm/en/langs/rust/",
	"title": "Rust",
	"tags": [],
	"description": "",
	"content": "Reference:\n "
},
{
	"uri": "https://safersys.github.io/mm/en/os/rust/",
	"title": "OS in Rust",
	"tags": [],
	"description": "",
	"content": "Reference: Writing an OS in Rust\n "
},
{
	"uri": "https://safersys.github.io/mm/en/sva/safecode/2002controlc/",
	"title": "Control-C",
	"tags": [],
	"description": "",
	"content": " Control-C (in 2002 CASES1) , a subset of C, but with key restrictions designed to ensure that memory safety of code can be verified entirely by static checking, under certain system assumptions.\nRestrictions on C  T1. Requires strong typing of all functions, variables, assignments, and expressions, using the same types as in C.\n T2. Disallows casts to or from any pointer type. Casts between other types (e.g., intergers, floating point numbers, and characters) are allowed.\n T3. A union can only contain types that can be cast to each other; consequently a union cannot contain a pointer type.\n T4. No uses of uninitialized local pointer variables within a procedure. A pointer variable must be assigned a value before it is used or address is taken.\n  For example:\nint a, *p, **pp; pp = \u0026amp;p; print (**pp); p = \u0026amp;a;  p is uninitialized and cannot be assigned to pp. Dereferencing p via **pp is potentially unsafe and this violation would be difficult to detect.\nThe language therefore disallows taking the address of an uninitialized pointer.\n T5. If reserved address is used, then any individual data object should be no larger than the size of the reserved address range.\n Reserved address is leveraged to avoid null pointer checks at runtime (replaced with HW checks).  T6. Pointer arithmetic is disallowed.\n array traversals must be done using explicit array indexing in Control-C. string traversals must use strlen followed by explicit array index operations; A safe string library operations can also be provided.   Restrictions on Array Operations Limitation of symbolic integer analysis One of the fundamental limits in static program analysis lies in the analysis of contraints on symbolic integer expressions. For ensuring safety, the compiler must prove (symbolically) that the index expressions in an array reference lie within the corresponding array bounds on all possible execution path. For each index expression, this can be formulated as an integer contraint system with equalities, inequalities, and logical operators used to represent the computation and control-flow statements of the program.\n\u0026ldquo;Unfortunately, integer constrains with multiplication of symbolic variables is undecidable\u0026rdquo;.\nA broad, decidable class of symbolic integer constraints is Presburger arithmetic, which allows addition, subtraction, multiplication by constants, and the logical connectives $\\vee, \\wedge, \\neg, \\exists $ and $\\forall$. Omega library provides an efficient implementation that has been widely used for solving such integer programming problems in compiler research.\nExploiting static analysis based on Presburger arithmetic requires that our language only allows linear expressions with constant(known) coefficients for all computations that determine the set of values accessed by an array index expression.\nArray operation rules Definition of affine transformation: Let $F: R^n \\rightarrow R$, then a transformation, $F$, is said to be affine if $F(\\overrightarrow{\\rm p}) = C\\overrightarrow{\\rm p} + \\overrightarrow{\\rm q}$, where $C$ is any linear transformation, and $\\overrightarrow{\\rm q}$ contains only constants or known symbolic variables independent of $\\overrightarrow{\\rm p}$.\nIn the following, we assume affine transformations with known constant integer coefficients ($C$).\nArray operations in Control-C must obey the following rules. On all control flow paths,\n A1. The index expression used in an array access must evaluate to a value within the bounds of the array. A2. For all dynamically allocated arrays, the size of the array has to be a positive expression. A3. If an array, A, is accessed inside a loop, then:\n the bounds of the loop have to be provably affine transformations of the size of $A$ an outer loop index variables or vice versa;** ??? **the index expression in the array reference, has to be provably an affine transformation of the vector of loop index variables, or an affine transformation of the size of $A$; and if the index expression in the array reference depends on a symbolic variable $s$ which is independent of the loop index variable (i.e., appears in the constant term $\\overrightarrow{\\rm q}$ in the affine representation), then the memory locations accessed by that reference have to be provably independent of the value of $s$.  A4. If an array is accessed outside of a loop then\n the index expression of the array has to be provably an affine expression of the length of the array.   The compiler can statically check a program satisfies A1 only if the additional language rules A2 \u0026ndash; A4 are obeyed.\nExample:\n... /*** caller function ***/ if (( k \u0026gt; 0) \u0026amp;\u0026amp; (k \u0026lt; 5)) { B = (int *)RMalloc(k * 30); C = initialize(B, 20); } int * initialize(int *B, int n) { int *A,m; if (B[n] \u0026gt; 0) { A = (int *) RMalloc(5 * B[n] + 10); for (m=0; m \u0026lt; B[n]; ++m) A[m*4] = m ; return A; } else return null; } The code above is a valid Control-C because:\n $ n = 20$ can be proven to be an affine function of the size of $B$ (A4); $ m * 4 $ is clearly an affine function of $m$ (A3(2)); and the bounds of the loop ($0$ and $B[n]$) can be proven to be affine functions of the size of $A$ (A3(a)).  Once the above three conditions are satisfied, the compiler proves A1 for all array accesses.\nNote that for proving safety of $B[n]$, the compiler has to correctly include the constraint on $k$ ($ k \u0026lt; 5 $) and only then it can verify that $n(=20)$ is less than the size of $B$.\n Ensuring Code Safety Without Runtime Checks for Real-Time Control Systems. CASES, 2002. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/sva/safecode/runtimechecks/arraychecks/",
	"title": "Arraychecks",
	"tags": [],
	"description": "",
	"content": " Reference1\nExtension to JK and JKRL.\nSummary of Jones-Kelly from 2006ICSE1: Jones-Kelly inserts the following checks (ignoring any later optimizaiton) on each arithmetic operation involving a pointer value:\n JK1. check the source pointer is not the invalid value (-2); JK2. find referent object for the source pointer value using the table; JK3. check that the result pointer value is within the bounds of this referent object plus the extra byte. If the result pointer exceeds the bounds, the result -2 is returned to mark the pointer value as valid. JK4. Finally, on any load or store, perform checks[JK1-JK3] but JK3 checks the source pointer itself.  Argument in ICSE 2006:\n if dereference -2 is not allowed by operating system, the JK4 check before loads/stores is strictly not necessary for bound checking; but useful for dangling pointers and cast errors. JK2 is most expensive. If JK2 did not found object, runtime check is skipped, and array bound violations may not be detected. One byte padded to allocated objects.  Not all object are padded during analysis: when inserting padding between two adjacent parameters could cause the memory layout of parameters to differ in check and unchecked code. Therefore: no pad to any function call if the call may invoke an unchecked function \u0026amp; no pad to formal parameters in any function that may be called from unchecked code. AND indirect calls must be treated conservatively.   Summary of Ruwase-Lam Extension To solve the illegal immediate problem that larger than 1 byte out of bounds, Ruwase and Lam extend the JK algorithm essentially by tracking the intended referent of pointers explicitly but only in the case where a pointer moves out of bounds of its intended referent.\n For every out-of-bounds pointer, an extra OOB object is allocated to hold some metadata for the pointer. The pointer itself is modified to point to the OOB object. The OOB contains actual pointer value, and the address of intended object (saved when the pointer first goes out of bounds).\n All OOB objects are stored in the hash table. The hash table is checked only before accessing the OOB object to ensure it is a valid OOB object address.\n All further arithmetic on the OOB pointer is performed on the value in the OOB object.\n If the pointer value comes back within bounds, the original pointer is restored to its current value and the OOB object is deallocated.\n  Argument in ICSE 2006:\n Extra overhead for out-of-bound pointers\n When object deallocated, having to scan OOB object hash table to deallocate any OOB objects that are corresponding to the freed object.\n  Key improvements to JKRL  Exploiting automatic pool allocation for much faster searches for referent objects;\n Instead of using one large splay tree for the entire program, we maintain one splay tree per pool; The lookup for each pointer access is much faster.  An extra level of indirection in the RL approach for OOB pointers that eliminates the need for run-time checks on most loads and stores.\n  Extension to Automatic Pool Allocation Handing non-heap data: original pool allocation only create pools for heap allocated data; Previous memory safety work assigns pool descriptors for all global and stack objects, but did not change how they are allocated.\n Pool allocation is extended to handle globals and stack data, also have partions for globals and stack, avoiding large splay trees. modified to create \u0026ldquo;dummy\u0026rdquo; pool descriptors for nodes that included only global or stack objects: A logical handle to a compiler-chosen subset of memory objects. automatically ensures the objects are created in the appropriate function. (e.g, in main if the node includes any globals). Record each object in the splay tree for the correpsonding pool.  in main for global objects in appropriate function for stack allocated variables (many local variables are promoted to registers and do not need to be stack-allocated or recorded).   OOB pointers Ruwas-Lam exetension to handle OOB pointers requires expensive checks on all loads/stores in the program (before the optimization via elimination of redundant checks).\nIn this work, don\u0026rsquo;t have to check all load/stores.\n A separate OOB hash-table per pool.\n Instead of returning the address of the OOB object and recording it in the out-of-bound pointer variable, we return an illegal (reserved) address. (trap upon access).\n A second hash table for each pool: mapping the returned value and the OOB object.\n When do pointer arithmetic on such OOB values, search for OOB object  On every pointer arithmetic $ p = q + c$:\n check whether $q$ is reserved address; if not reserved: do bound check; if out of bounds, create new OOB object, new reserved address, and their mappings in hash table, assign $p$ as reserved address; if reserved: get OOB; get original pointer value from OOB; do arithmetic; check new pointer value: if out of bounds, a new OOB; if in bounds, assign to $p$.   Weakness  (From 2006 ICSE, ch 3.2.1 ) For pointers with no known pool descriptors: no bounds check.  May not known either if the pointer q is derived from an integer-to-pointer cast or from unchecked code (e.g, as a result of a call the an external function). For int-to-ptr cast, which result in a U (Unknown) flag, the pointer may actually point to an object in some pool, but we don\u0026rsquo;t know which pool at compile time. We do not check pointer arithmetic on such pointers, which is weaker than Jones-Kelly as it allows bound violation goes undetected.    Backwards-Compatible Array Bounds Checking for C with Very Low Overhead, ICSE, 2006. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/prog-ana/fm/hott/intro/",
	"title": "Intro",
	"tags": [],
	"description": "",
	"content": "Reference1\n referee ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/prog-ana/fm/hott/",
	"title": "Hott",
	"tags": [],
	"description": "",
	"content": "Reference1\n \u0026ldquo;Homotopy Type Theory: Univalent Foundations of Mathematics\u0026rdquo;. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/mem-safe/runtimecheck/jones-kelly/",
	"title": "Jones Kelly",
	"tags": [],
	"description": "",
	"content": " Reference1\nEarlier work:\nIn this work,\n pointer representations are not changed. A table of all known valid storage objects:\n mapping a pointer to an object descriptor; the descriptor contains the base, extent and additional information of the object.  All pointer arithmetic and pointer use are checked.\n arithmetic result must refer to the same object; every pointer-valued expression must derive its result from one original object. Incorrectly derived pointers are replaced with an illegal pointer value ((void *)-2).   Example: pointers to objects.\nPermitted operations for pointers above:\nObject/pinter tracking: track object when created/deleted:\n static: global variables, static variables in functions, and string constants: compiler/linker change. dynamic: malloc/free/mmap/sbrk: C library change. stack objects:  Each object is padded by 1 byte. GCC alloca function. De-register: constructor/destructor mechanism. The following compilation happens:   int sum (int n, int *a){ int i, s = 0; for (i = 0; i \u0026lt; n; ++i) s += a[i]; return s; } Compiled to\nint sum (int n, int *a){ /* bounds push function enters a function context. A * matching call to bounds pop function will * delete parameters. */ __bounds_push_function (\u0026#34;sum\u0026#34;); __bounds_add_parameter_object (\u0026amp;n, sizeof (int), ...); __bounds_add_parameter_object (\u0026amp;a, sizeof (int*), ...); /* Extra scope created around the function. GCC will * call bounds pop function when leaving this * scope. */ { /* Declare stack objects, and use GCC\u0026#39;s destructor * mechanism to ensure __bounds_delete_stack_object is * called for each variable however we leave scope * (even if we leave with goto). */ int i; __bounds_add_stack_object (\u0026amp;i, sizeof (int), ...); int s = u; __bounds_add_stack_object (\u0026amp;s, sizeof (int), ...); for (i = 0; i \u0026lt; n; ++i) s += *(int*)__bounds_check_array_reference(a, i, sizeof (int), ...); __bounds_delete_stack_object(\u0026amp;s); __bounds_delete_stack_object(\u0026amp;i); } end; __bounds_pop_function(\u0026#34;sum\u0026#34;); /* Delete a, n. */ return s; } goto example. Figure 4: goto label1 creates b and goto label2 destroys b.\nCorner Cases:\n pointers passed from unchecked code to checked code:  If points to registered object: can be derived from another object (registered or unregisterd), cannot detect. If points to unregistered object: can detect and report, but allow such error.  pointers passed from checked code to unchecked code:  unchecked accesses can occur.   Splay trees to look up pointers:\n Binary tree where frequently used nodes migrate towards the top of the tree; on average, the look-up function was iterated 2.11 times per call on a typical large program. unrolled first two iterations of the loop to optimise these cases.  A Brief summary from ICSE 20062 Jones-Kelly inserts the following checks (ignoring any later optimizaiton) on each arithmetic operation involving a pointer value:\n JK1. check the source pointer is not the invalid value (-2); JK2. find referent object for the source pointer value using the table; JK3. check that the result pointer value is within the bounds of this referent object plus the extra byte. If the result pointer exceeds the bounds, the result -2 is returned to mark the pointer value as valid. JK4. Finally, on any load or store, perform checks[JK1-JK3] but JK3 checks the source pointer itself.   Backwards-compatible bounds checking for arrays and pointers in C programs, here. In Automated \u0026amp; Algorithmic Debugging, 1997. ↩ Backwards-Compatible Array Bounds Checking for C with Very Low Overhead, ICSE, 2006. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/mem-safe/runtimecheck/ruwas-lam/",
	"title": "Ruwas Lam",
	"tags": [],
	"description": "",
	"content": "Reference1\nA brief summary from ICSE 2006[^ICSE2006]:\nTo solve the illegal immediate problem that larger than 1 byte out of bounds, Ruwase and Lam extend the JK algorithm essentially by tracking the intended referent of pointers explicitly but only in the case where a pointer moves out of bounds of its intended referent.\n For every out-of-bounds pointer, an extra OOB object is allocated to hold some metadata for the pointer. The pointer itself is modified to point to the OOB object. The OOB contains actual pointer value, and the address of intended object (saved when the pointer first goes out of bounds).\n All OOB objects are stored in the hash table. The hash table is checked only before accessing the OOB object to ensure it is a valid OOB object address.\n All further arithmetic on the OOB pointer is performed on the value in the OOB object.\n If the pointer value comes back within bounds, the original pointer is restored to its current value and the OOB object is deallocated.\n   referee ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/mem-safe/runtimecheck/",
	"title": "Runtime Bound Checking",
	"tags": [],
	"description": "",
	"content": " Reference1\nRuntime Bounds Checking Reference: Runtime Defenses agains Memory Corruption, or here\nThree kinds of solutions:\n Modified pointer representation.  Pointer keeps information about its referent object Incompatible with external code, libraries, etc.  Special table maps pointers to referent objects\n Check referent object on every dereference What if a pointer is modified by external code?  Keep track of address range of each object\n For every pointer arithmetic operation, check that the results points to the same referent object.   Examples:\n Jones-Kelly2: pad each object by 1 byte; maintain a runtime tree of allocated objects; replace all out-of-bound addresses with illegal value; backwards-compatible pointer representation.\n What if a pointer to an out-of-bounds address is used to compute an in-bounds address? ==\u0026gt; Result: False alarm. details  Ruwas-Lam3: catch out-of-bounds pointers at runtime.\n Requires instrumentation of malloc() and a special runtime environment. Out-of-bounds pointer pointer to a special OOB object: stores the original out-of-bounds value; stores a pointer to the original referent object. Pointer arithmetic on out-of-bounds pointers: details     Runtime Defenses agains Memory Corruption, here. ↩ Backwards-compatible bounds checking for arrays and pointers in C programs, here. In Automated \u0026amp; Algorithmic Debugging, 1997. ↩ A Practical Dynamic Buffer Overflow Detector, here. NDSS, 2004. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/prog-ana/interprocedural/cfg/",
	"title": "Call Graphs",
	"tags": [],
	"description": "",
	"content": "Reference1\nIf the program includes the use of a procedure parameter or functin pointer, the target generally is not known until the program is run and, in fact, may vary from one invocation to another. Then, a call site can link to many or all procedures in the call graph.\nIndirect calls are the norm for object-oriented programming languages. When there is overriding of methods in subclasses, a use of method m may refer to any of a number of different methods, depending on the subclass of the receiver object to which it was applied. The use of such virtual method invocations means that we need to know the type of the receiver before we can determine which method is invoked.\n Compilers: Principles, Techniques, \u0026amp; Tools. 2nd ed, ch12.1.1. 2007. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/prog-ana/interprocedural/",
	"title": "Interprocedural",
	"tags": [],
	"description": "",
	"content": " Ch12 of Dragon Book1.\nIntra-procedural Analysis Most compiler optimizations are performed on procedures one at a time. We refer to such analyses as intraprocedural. These analyses conservatively assume that procedures invoked may alter the state of all the variables visible to the procedures and that they may create all possible side effects, such as modifying any of the variables visible to the procedure or generating exceptions that cause the unwinding of the call stack.\nIntraprocedural analysis is thus relatively simple, albeit imprecise.\nSome optimizations do not need interprocedural analysis, while others may yield almost no useful information without it.\nInter-procedural Analysis An interprocedural analysis operates across an entire program, flowing information from the caller to its callees and vice versa.\ninline procedures: only applicable if we know the target of the procedure call; will increase code size exponentially.\nIf procedures are invoked indirectly through a pointer or via the method dispatch mechanism prevalent in object-oriented programming, analysis of the program\u0026rsquo;s pointers or references can in some cases determine the targets of the indirect invocations. If there is a unique target, inlining can be applied. Even if a unique target is determined for each procedure invocation, inlining must be applied judiciously. In general, it is not possible to inline recursive procedures directly, and even without recursion, inlining can expand the code size exponentially.\n Compilers: Principles, Techniques, \u0026amp; Tools, 2nd ed, 2007. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/sva/dsa/passes/localdatastructures/",
	"title": "LocalDataStructures",
	"tags": [],
	"description": "",
	"content": "Computes the local data structure graphs for all of the functions in the program.\n Implemeted as a module pass; but should be a function pass.  Reference1\nClass definition in DataStructure.h:\n// // FIXME: This should be a Function pass that can be USED by a Pass, and would be automatically preserved. Until we can do that, this is a Pass. // classLocalDataStructures : public DataStructures { AddressTakenAnalysis* addrAnalysis; public: static char ID; LocalDataStructures() : DataStructures(ID, \u0026#34;local.\u0026#34;) {} ~LocalDataStructures() { releaseMemory(); } virtual bool runOnModule(Module \u0026amp;M); /// getAnalysisUsage - This obviously provides a data structure graph.  ///  virtual void getAnalysisUsage(AnalysisUsage \u0026amp;AU) const { AU.addRequired\u0026lt;AddressTakenAnalysis\u0026gt;(); AU.setPreservesAll(); } };  code ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/sva/dsa/passes/datastructures/",
	"title": "DataStructures",
	"tags": [],
	"description": "",
	"content": "Reference1\nDefined in DataStructure.h:\nclassDataStructures : public ModulePass { typedef std::map\u0026lt;const Function*, DSGraph*\u0026gt; DSInfoTy; /// DataLayout, comes in handy  const DataLayout* TD; /// Pass to get Graphs from  DataStructures* GraphSource; /// Do we clone Graphs or steal them?  bool Clone; /// do we reset the aux list to the func list?  bool resetAuxCalls; /// Were are DSGraphs stolen by another pass?  bool DSGraphsStolen; void buildGlobalECs(svset\u0026lt;const GlobalValue*\u0026gt;\u0026amp; ECGlobals); void eliminateUsesOfECGlobals(DSGraph\u0026amp; G, const svset\u0026lt;const GlobalValue*\u0026gt; \u0026amp;ECGlobals); // DSInfo, one graph for each function  DSInfoTy DSInfo; // Name for printing  const char* printname; protected: /// The Globals Graph contains all information on the globals  DSGraph *GlobalsGraph; /// GlobalECs - The equivalence classes for each global value that is merged  /// with other global values in the DSGraphs.  EquivalenceClasses\u0026lt;const GlobalValue*\u0026gt; GlobalECs; SuperSet\u0026lt;Type*\u0026gt;* TypeSS; // Callgraph, as computed so far  DSCallGraph callgraph; // List of all address taken functions.  // This is used as target, of indirect calls for any indirect call site with // incomplete callee node.  std::vector\u0026lt;const Function*\u0026gt; GlobalFunctionList; void init(DataStructures* D, bool clone, bool useAuxCalls, bool copyGlobalAuxCalls, bool resetAux); void init(const DataLayout* T); void formGlobalECs(); void cloneIntoGlobals(DSGraph* G, unsigned cloneFlags); void cloneGlobalsInto(DSGraph* G, unsigned cloneFlags); void restoreCorrectCallGraph(); void formGlobalFunctionList(); DataStructures(char \u0026amp; id, const char* name) : ModulePass(id), TD(0), GraphSource(0), printname(name), GlobalsGraph(0) { // For now, the graphs are owned by this pass  DSGraphsStolen = false; } public: /// print - Print out the analysis results...  ///  void print(llvm::raw_ostream \u0026amp;O, const Module *M) const; void dumpCallGraph() const; /// handleTest - Handles various user-specified testing options.  /// Returns true iff the user specified for us to test something.  ///  bool handleTest(llvm::raw_ostream \u0026amp;O, const Module *M) const; virtual void releaseMemory(); virtual bool hasDSGraph(const Function \u0026amp;F) const { return DSInfo.find(\u0026amp;F) != DSInfo.end(); } /// getDSGraph - Return the data structure graph for the specified function.  ///  virtual DSGraph *getDSGraph(const Function \u0026amp;F) const { std::map\u0026lt;const Function*, DSGraph*\u0026gt;::const_iterator I = DSInfo.find(\u0026amp;F); assert(I != DSInfo.end() \u0026amp;\u0026amp; \u0026#34;Function not in module!\u0026#34;); return I-\u0026gt;second; } void setDSGraph(const Function\u0026amp; F, DSGraph* G) { DSInfo[\u0026amp;F] = G; } DSGraph* getOrCreateGraph(const Function* F); DSGraph* getGlobalsGraph() const { return GlobalsGraph; } EquivalenceClasses\u0026lt;const GlobalValue*\u0026gt; \u0026amp;getGlobalECs() { return GlobalECs; } const DataLayout\u0026amp; getDataLayout() const { return *TD; } const DSCallGraph\u0026amp; getCallGraph() const { return callgraph; } SuperSet\u0026lt;Type*\u0026gt;\u0026amp; getTypeSS() const { return *TypeSS; } /// deleteValue/copyValue - Interfaces to update the DSGraphs in the program.  /// These correspond to the interfaces defined in the AliasAnalysis class.  void deleteValue(Value *V); void copyValue(Value *From, Value *To); };  referee ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/sva/dsa/passes/tddatastructures/",
	"title": "TDDataStructures",
	"tags": [],
	"description": "",
	"content": "Reference1\nClass definition in DataStructure.h, drived from class DataStructures:\n// TDDataStructures // - Analysis that computes new data structure graphs for each function using the closed graphs for the callers computed by the bottom-up pass.  classTDDataStructures : public DataStructures { svset\u0026lt;const Function*\u0026gt; ExternallyCallable; /// CallerCallEdges - For a particular graph, we keep a list of these records  /// which indicates which graphs call this function and from where.  struct CallerCallEdge { DSGraph *CallerGraph; // The graph of the caller function.  const DSCallSite *CS; // The actual call site.  const Function *CalledFunction; // The actual function being called.  CallerCallEdge(DSGraph *G, const DSCallSite *cs, const Function *CF) : CallerGraph(G), CS(cs), CalledFunction(CF) {} bool operator\u0026lt;(const CallerCallEdge \u0026amp;RHS) const { return CallerGraph \u0026lt; RHS.CallerGraph || (CallerGraph == RHS.CallerGraph \u0026amp;\u0026amp; CS \u0026lt; RHS.CS); } }; std::map\u0026lt;DSGraph*, std::vector\u0026lt;CallerCallEdge\u0026gt; \u0026gt; CallerEdges; // IndCallMap - We memoize the results of indirect call inlining operations that have multiple targets here to avoid N*M inlining. The key to the map is a sorted set of callee functions, the value is the DSGraph that holds all of the caller graphs merged together, and the DSCallSite to merge with the arguments for each function.  std::map\u0026lt;std::vector\u0026lt;const Function*\u0026gt;, DSGraph*\u0026gt; IndCallMap; bool useEQBU; public: static char ID; TDDataStructures(char \u0026amp; CID = ID, const char* printname = \u0026#34;td.\u0026#34;, bool useEQ = false) : DataStructures(CID, printname), useEQBU(useEQ) {} ~TDDataStructures(); virtual bool runOnModule(Module \u0026amp;M); /// getAnalysisUsage - This obviously provides a data structure graph.  virtual void getAnalysisUsage(AnalysisUsage \u0026amp;AU) const { if (useEQBU) { AU.addRequired\u0026lt;EquivBUDataStructures\u0026gt;(); } else { AU.addRequired\u0026lt;BUDataStructures\u0026gt;(); AU.addPreserved\u0026lt;BUDataStructures\u0026gt;(); } AU.setPreservesAll(); } private: void markReachableFunctionsExternallyAccessible(DSNode *N, DenseSet\u0026lt;DSNode*\u0026gt; \u0026amp;Visited); void InlineCallersIntoGraph(DSGraph* G); void ComputePostOrder(const Function \u0026amp;F, DenseSet\u0026lt;DSGraph*\u0026gt; \u0026amp;Visited, std::vector\u0026lt;DSGraph*\u0026gt; \u0026amp;PostOrder); };  github code: DataStructure.h  ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/sva/dsa/passes/eqtddatastructures/",
	"title": "EQTDDataStructures",
	"tags": [],
	"description": "",
	"content": "Reference1:\nEQTDDataStructures is the ``final\u0026rdquo; form of DSA and is probably the appropriate pass for most external clients to use. By including this pass, a client will get the results of the DSA analysis after all phases of DSA have been run. Merging has been performed for aliasing in both callers and callees, so fewer nodes will be incomplete than in bottom-up. Aliasing information will therefore be most precise.\nThe primary disadvantage of using EQTDDataStructures is the loss of precision caused by the additional merging of nodes relative to bottom-up. Depending on the needs of a client, therefore, EquivBuDataStructures may be more appropriate in specific cases.\nClass definition in DataStructure.h: derived from TDDataStructures\n/// EQTDDataStructures - Analysis that computes new data structure graphs /// for each function using the closed graphs for the callers computed /// by the EQ bottom-up pass. /// classEQTDDataStructures : public TDDataStructures { public: static char ID; EQTDDataStructures() :TDDataStructures(ID, \u0026#34;eqtd.\u0026#34;, true) {} ~EQTDDataStructures(); };  EQTDDataStructure doc in manual ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/sva/dsa/passes/",
	"title": "Passes",
	"tags": [],
	"description": "",
	"content": " LocalDataStructures  Computes the local data structure graphs for all of the functions in the program. Implemeted as a module pass; but should be a function pass. Reference1 Class definition in DataStructure.h: // // FIXME: This should be a Function pass that can be USED by a Pass, and would be automatically preserved. Until we can do that, this is a Pass. // classLocalDataStructures : public DataStructures { AddressTakenAnalysis* addrAnalysis; public: static char ID; LocalDataStructures() : DataStructures(ID, \u0026#34;local.\n DataStructures  Reference1 Defined in DataStructure.h: classDataStructures : public ModulePass { typedef std::map\u0026lt;const Function*, DSGraph*\u0026gt; DSInfoTy; /// DataLayout, comes in handy const DataLayout* TD; /// Pass to get Graphs from DataStructures* GraphSource; /// Do we clone Graphs or steal them? bool Clone; /// do we reset the aux list to the func list? bool resetAuxCalls; /// Were are DSGraphs stolen by another pass? bool DSGraphsStolen; void buildGlobalECs(svset\u0026lt;const GlobalValue*\u0026gt;\u0026amp; ECGlobals); void eliminateUsesOfECGlobals(DSGraph\u0026amp; G, const svset\u0026lt;const GlobalValue*\u0026gt; \u0026amp;ECGlobals); // DSInfo, one graph for each function DSInfoTy DSInfo; // Name for printing const char* printname; protected: /// The Globals Graph contains all information on the globals DSGraph *GlobalsGraph; /// GlobalECs - The equivalence classes for each global value that is merged /// with other global values in the DSGraphs.\n TDDataStructures  Reference1 Class definition in DataStructure.h, drived from class DataStructures: // TDDataStructures // - Analysis that computes new data structure graphs for each function using the closed graphs for the callers computed by the bottom-up pass. classTDDataStructures : public DataStructures { svset\u0026lt;const Function*\u0026gt; ExternallyCallable; /// CallerCallEdges - For a particular graph, we keep a list of these records /// which indicates which graphs call this function and from where. struct CallerCallEdge { DSGraph *CallerGraph; // The graph of the caller function.\n EQTDDataStructures  Reference1: EQTDDataStructures is the ``final\u0026rdquo; form of DSA and is probably the appropriate pass for most external clients to use. By including this pass, a client will get the results of the DSA analysis after all phases of DSA have been run. Merging has been performed for aliasing in both callers and callees, so fewer nodes will be incomplete than in bottom-up. Aliasing information will therefore be most precise. The primary disadvantage of using EQTDDataStructures is the loss of precision caused by the additional merging of nodes relative to bottom-up.\n "
},
{
	"uri": "https://safersys.github.io/mm/en/sva/safecode/passes/stackcheck/",
	"title": "Stack Check",
	"tags": [],
	"description": "",
	"content": "Reference1\nsafecode/include/StackSafety.h:  This file defines checks for stack safety.\nstruct checkStackSafety : public ModulePass { public : ... virtual bool runOnModule(Module \u0026amp;M); virtual void getAnalysisUsage(AnalysisUsage \u0026amp;AU) const { AU.addRequired\u0026lt;DataLayout\u0026gt;(); AU.addRequired\u0026lt;EQTDDataStructures\u0026gt;(); AU.setPreservesAll(); } private : //  // Tracks the DSNodes that have already been analyzed by an invocation of  // markReachableAllocas().  //  std::set\u0026lt;DSNode *\u0026gt; reachableAllocaNodes; bool markReachableAllocas(DSNode *DSN, bool start=false); bool markReachableAllocasInt(DSNode *DSN, bool start=false); }; } }  safecode/lib/StackSafety/CheckStackPointer.cpp:  Implementation of StackSafety.h\n\u0026ldquo;FixMe: Can this pass get better results by using another DSA pass? It seems this pass may be too conservative by using the Top-Down DSA results.\u0026rdquo;\n runOnModule(): no changes.  EQTDDataStructures: An DSA pass that \u0026ldquo;computes new data structure graphs for each function using the closed graphs for the callers computed by the EQ bottom-up pass.\u0026rdquo; more   bool checkStackSafety::runOnModule(Module \u0026amp;M) { // TDDataStructures *TDDS;  // TDDS = \u0026amp;getAnalysis\u0026lt;TDDataStructures\u0026gt;();  EQTDDataStructures *BUDS; BUDS = \u0026amp;getAnalysis\u0026lt;EQTDDataStructures\u0026gt;(); //  // Get a pointer to the entry of the program.  //  Function *MainFunc = M.getFunction(\u0026#34;main\u0026#34;) ? M.getFunction(\u0026#34;main\u0026#34;) : M.getFunction (\u0026#34;MAIN__\u0026#34;); //  // Scan each function and look for stack objects which can escape from the  // function.  //  for (Module::iterator MI = M.begin(), ME = M.end(); MI != ME; ++MI) { Function \u0026amp;F = *MI; if (\u0026amp;F != MainFunc) { if (!F.isDeclaration()) { DSGraph * BUG = BUDS-\u0026gt;getDSGraph(F); //  // If the function can return a pointer, see if a stack object can  // escape via the return value.  //  if (isa\u0026lt;PointerType\u0026gt;(F.getReturnType())) { for (inst_iterator ii = inst_begin(F), ie = inst_end(\u0026amp;F); ii != ie; ++ii) { if (ReturnInst *RI = dyn_cast\u0026lt;ReturnInst\u0026gt;(\u0026amp;*ii)) { DSNode *DSN = BUG-\u0026gt;getNodeForValue(RI).getNode(); if (DSN) { markReachableAllocas(DSN); } } } } //  // Conservatively assume that any stack object reachable from one of  // the incoming arguments is a stack object that is placed there as an  // \u0026#34;output\u0026#34; by this function (or one of its callees).  //  Function::arg_iterator AI = F.arg_begin(), AE = F.arg_end(); for (; AI != AE; ++AI) { if (isa\u0026lt;PointerType\u0026gt;(AI-\u0026gt;getType())) { DSNode *DSN = BUG-\u0026gt;getNodeForValue(AI).getNode(); markReachableAllocas(DSN, true); } } //  // Any stack object that is reachable by a global may also escape the  // function. Scan both for local variables that may alias with globals  // as well as globals that are directly accessed by the function.  //  DSGraph::node_iterator DSNI = BUG-\u0026gt;node_begin(), DSNE = BUG-\u0026gt;node_end(); for (; DSNI != DSNE; ++DSNI) { if (DSNI-\u0026gt;isGlobalNode()) { markReachableAllocas(DSNI); } } DSGraph * GlobalGraph = BUG-\u0026gt;getGlobalsGraph(); DSNI = GlobalGraph-\u0026gt;node_begin(), DSNE = GlobalGraph-\u0026gt;node_end(); for (; DSNI != DSNE; ++DSNI) { if (DSNI-\u0026gt;isGlobalNode()) { markReachableAllocas(DSNI); } } } } } //  // This pass never changes the module; always return false.  //  return false; }   markReachableAllocasInt(DSNode *DSN, bool start): Find all of the DSNodes that alias with stack objects and are reachable from the specified DSNode.  bool checkStackSafety::markReachableAllocasInt(DSNode *DSN, bool start) { bool returnValue = false; reachableAllocaNodes.insert(DSN); //  // If the initial node is an alloca node, then put it in the reachable set.  //  if (!start \u0026amp;\u0026amp; DSN-\u0026gt;isAllocaNode()) { returnValue = true; AllocaNodes.insert (DSN); } //  // Look at the DSNodes reachable from this DSNode. If they alias with the  // stack, put them in the reachable set.  //  DataLayout \u0026amp; TD = getAnalysis\u0026lt;DataLayout\u0026gt;(); for (unsigned i = 0, e = DSN-\u0026gt;getSize(); i \u0026lt; e; i += TD.getPointerSize()) if (DSNode *DSNchild = DSN-\u0026gt;getLink(i).getNode()) { if (reachableAllocaNodes.find(DSNchild) != reachableAllocaNodes.end()) { continue; } else if (markReachableAllocasInt(DSNchild)) { returnValue = returnValue || true; } } return returnValue; }  safecode/lib/StackSafety/ ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/sva/safecode/passes/arraybnd/",
	"title": "Static Array Bound Checks",
	"tags": [],
	"description": "",
	"content": "lib/ArrayBoundChecks: This library contains serveral analysis passes for static array bounds checking1.\nsafecode/lib/ArrayBoundChecks/ArrayBoundCheckLocal.cpp: \n\u0026ldquo;ArrayBoundsCheckLocal - It tries to prove a GEP is safe only based on local information, that is, the size of global variables and the size of objects being allocated inside a function.\u0026rdquo;\nCode sinppets:\nEntry:\nbool ArrayBoundsCheckLocal::runOnFunction(Function \u0026amp; F) { //  // Get required analysis passes.  //  TD = \u0026amp;F.getParent()-\u0026gt;getDataLayout(); SE = \u0026amp;getAnalysis\u0026lt;ScalarEvolution\u0026gt;(); //  // Look for all GEPs in the function and try to prove that they\u0026#39;re safe.  //  visit (F); //  // We modify nothing; return false.  //  return false; } //  // If the offset is less than zero, then we know that we are indexing  // backwards from the beginning of the object. We know that this is illegal;  // declare it unsafe.  //  if ((SE-\u0026gt;getSMaxExpr(offset, zero) == zero) \u0026amp;\u0026amp; (offset != zero)) { ++unsafeGEPs; return; } //  // Otherwise, we are indexing zero or more bytes forward. Determine whether  // we will index past the end of the object.  //  if ((SE-\u0026gt;getSMaxExpr(diff, zero) == diff) \u0026amp;\u0026amp; (diff != zero)) { ++safeGEPs; SafeGEPs.insert (\u0026amp;GEP); return; } //  // We cannot statically prove that the GEP is safe.  //  return;  Array Bound Proof/Check\nsafecode/lib/ArrayBoundChecks/ArrayBoundCheckStruct.cpp: \n\u0026ldquo;This file implements the ArrayBoundsCheckStruct pass. This pass utilizes type-safety information from points-to analysis to prove whether GEPs2 are safe (they do not create a pointer outside of the memory object). It is primarily designed to alleviate run-time checks on GEPs used for structure indexing (hence the clever name).\u0026rdquo;\nsafecode/lib/ArrayBoundChecks/BottomUpCallGraph.cpp: \n\u0026ldquo;I believe this pass does two things:\u0026rdquo;\n\u0026rdquo; o) It attempts to improve upon the call graph calculated by DSA for those call sites in which a callee was not found.\u0026rdquo;\n\u0026rdquo; o) It finds functions that are part of Strongly Connected Components (SCCs) in the call graph and marks them being a part of an SCC.\u0026rdquo;\n\u0026rdquo; FIXME: I believe the fixup of the call graph is no longer necessary; DSA asserts if it can\u0026rsquo;t find a callee for a call instruction.\u0026rdquo;\nsafecode/lib/ArrayBoundChecks/BreakConstantGEPs.cpp: \n\u0026ldquo; This pass changes all GEP constant expressions into GEP instructions. This permits the rest of SAFECode to put run-time checks on them if necessary.\u0026rdquo;\nsafecode/lib/ArrayBoundChecks/ConstraintGeneration.cpp \u0026ldquo; Now we use the control dependence, post dominance frontier to generate constraints for ?\u0026rdquo;\n SAFECode Software Architecture Manual ↩ GEP: GetElementPtr instruction in LLVM. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/sva/safecode/passes/ptrchecks/",
	"title": "Pass: Insert Pointer Checks",
	"tags": [],
	"description": "",
	"content": "Reference1\nC Zero Security Checks: \n\u0026ldquo;This transformation ensures that the code emitted (if there are no warnings) poses no security threat to the target system.\u0026rdquo;\nFree Removal Pass:\n\u0026ldquo;FIXME: This pass needs to be cleaned up and better understood. Some of the functionality seems to be addressed with poolcheckalign() in the Check Insertion pass; we should ensure that the functionality there is present in mainline and supercedes what is implemented here. Also, the checking of pool operations should be understood and updated/corrected if needed.\u0026rdquo;\n\u0026ldquo;This pass appears to do two things:\u0026rdquo;\n\u0026rdquo; o) It ensures that there are load/store checks on pointers that point to type-known data but are loaded from type-unknown partitions.\u0026rdquo;\n\u0026rdquo; o) It seems to perform some sort of sanity/correctness checking of pool creation/destruction.\u0026rdquo;\n\u0026ldquo;Original comment from initial implementation:\u0026rdquo; \u0026ldquo;Implementation of FreeRemoval.h : an EmbeC pass\u0026rdquo;\n\u0026ldquo;Some assumptions:\u0026rdquo;\n Correctness of pool allocation Destroys at end of functions.  \u0026ldquo;Pool pointer aliasing assumptions:\u0026rdquo;\n pool pointer copies via gep\u0026rsquo;s are removed no phinode takes two pool pointers because then they would be the same pool  \u0026ldquo;Result: If we look at pool pointer defs and look for their uses\u0026hellip; we check that their only uses are calls to pool_allocs, pool_frees and pool_destroys.\u0026rdquo;\n```\n src: safecode/lib/PointerChecks ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/sva/safecode/passes/poolchecks/",
	"title": "Pass: Insert Pool Checks",
	"tags": [],
	"description": "",
	"content": "lib/InsertPoolChecks. This library contains\n the transform passes for inserting run-time checks and for inserting code to register memory objects within individual pools. the CompleteChecks pass which implements the Check Completion Phase.  Alignment Checks:\n\u0026ldquo; This pass instruments the code with alignment checks. This is required when load/store checks on type-safe memory objects are optimized away; pointers to type-safe memory objects that are loaded from type-unsafe memory objects may not point to a valid memory object or may not be alignment properly within a valid memory object.\u0026rdquo;\nCFI Checks:\n\u0026ldquo;This pass instruments indirect function calls to ensure that control-flow integrity is preserved at run-time.\u0026rdquo;\nClear Check Attributes: \n\u0026ldquo;This file implements a pass to remove special attributes from the run-time checking functions.\u0026rdquo;\nComplete Checks: \n\u0026ldquo;This pass instruments loads and stores with run-time checks to ensure memory safety.\u0026rdquo;\nGEP Checks:\n\u0026ldquo;This pass instruments GEPs1 with run-time checks to ensure safe array and structure indexing.\u0026rdquo;\nInvalid Free Checks: \n\u0026ldquo;This pass instruments calls to deallocators to ensure memory safety.\u0026rdquo;\nRegister Bounds Passes:\n\u0026ldquo;Various passes to register the bound information of variables into the pools\u0026rdquo;\nRegister Runtime Initializer:\n\u0026ldquo;Pass to register runtime initialization calls into user-space programs.\u0026rdquo;\nRegister Stack Object Pass:\n\u0026ldquo;This pass instruments code to register stack objects with the appropriate pool.\u0026rdquo;\nTerminiate Pass: \n\u0026ldquo;Pass to modify SAFECode\u0026rsquo;s initialization in the program to terminate on the first memory safety error.\u0026rdquo;\n GEP: GetElementPtr instruction. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/riscv/attacks/sp-analog/",
	"title": "A2: Analog Malicious Hardware",
	"tags": [],
	"description": "",
	"content": "Reference1\n\u0026ldquo;In the open spaces of an already placed and routed design, we contruct a circuit that use capacitors to siphon charge from nearby wires as they transition between digital values.\u0026rdquo;\n\u0026ldquo;When the capacitors fully charge, they deploy an attack that forces a victim flip-flop to a desired value, e.g the privileged bit for the processor.\u0026rdquo;\n\u0026ldquo;We replace the hundreds of gates required by conventional counter-based triggers implemented using digital logic with analog components \u0026ndash; a capacitor and a few transistors wrapped-up in a single gate.\u0026rdquo;\n A2: Analog Malicious Hardware, SP, 2016. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/riscv/attacks/",
	"title": "Attacks",
	"tags": [],
	"description": "",
	"content": "Reference1\n A2: Analog Malicious Hardware  Reference1 \u0026ldquo;In the open spaces of an already placed and routed design, we contruct a circuit that use capacitors to siphon charge from nearby wires as they transition between digital values.\u0026rdquo; \u0026ldquo;When the capacitors fully charge, they deploy an attack that forces a victim flip-flop to a desired value, e.g the privileged bit for the processor.\u0026rdquo; \u0026ldquo;We replace the hundreds of gates required by conventional counter-based triggers implemented using digital logic with analog components \u0026ndash; a capacitor and a few transistors wrapped-up in a single gate.\n  referee ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/mem-safe/cets/runtime/",
	"title": "Runtime Library of CETS",
	"tags": [],
	"description": "",
	"content": "file: safecode/runtime/SoftBoundRuntime/softboundcets.c and .h:\ntypedef struct { void* base; void* bound; size_t key; void* lock; } __softboundcets_trie_entry_t; A shadow stack:\n void __softboundcets_allocate_shadow_stack_space(int num_pointer_args) void* __softboundcets_load_base_shadow_stack(int arg_no) void* __softboundcets_load_bound_shadow_stack(int arg_no) key, lock\u0026hellip; store base/bound/key/lock __softboundcets_stack_memory_allocation(void** ptr_lock, size_t* ptr_key)   Bound check:\n void __softboundcets_spatial_call_dereference_check(void* base, void* bound, void* ptr) void __softboundcets_spatial_load_dereference_check(void *base, void *bound, void *ptr, size_t size_of_type) void __softboundcets_spatial_store_dereference_check(void *base, void *bound, void *ptr, size_t size_of_type) void __softboundcets_memcopy_check_i64(char* ptr, char* ptr_base, char* ptr_bound, size_t size) void __softboundcets_memcopy_check(char* dest, char* dest_base, char* dest_bound, char* src, char* src_base, char* src_bound, size_t size) void __softboundcets_temporal_load_dereference_check(void* pointer_lock, size_t key,void* base, void* bound) void __softboundcets_temporal_store_dereference_check(void* pointer_lock, size_t key,void* base, void* bound)   Metadata load/store:\n void __softboundcets_metadata_store(void* addr_of_ptr, void* base, void* bound, size_t key, void* lock) void __softboundcets_metadata_load(void* addr_of_ptr, void** base, void** bound, size_t* key, void** lock)  Memory alloca/dealloc:\n void __softboundcets_memory_deallocation(void* ptr_lock, size_t ptr_key)\n void* __softboundcets_allocate_lock_location()\n void __softboundcets_allocation_secondary_trie_allocate_range(void* initial_ptr, size_t size)\n void __softboundcets_allocation_secondary_trie_allocate(void* addr_of_ptr)\n void __softboundcets_memory_allocation(void* ptr, void** ptr_lock, size_t* ptr_key)\n void* __softboundcets_get_global_lock()\n void __softboundcets_add_to_free_map(size_t ptr_key, void* ptr)\n void __softboundcets_check_remove_from_free_map(size_t ptr_key, void* ptr)\n  void * __softboundcets_safe_mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset){ return mmap(addr, length, prot, flags, fd, offset); } void* __softboundcets_safe_calloc(size_t nmemb, size_t size){ return calloc(nmemb, size); } void* __softboundcets_safe_malloc(size_t size){ return malloc(size); } void __softboundcets_safe_free(void* ptr){ free(ptr); } file: safecode/runtime/SoftBoundRuntime/softboundcets-wrappers.c:\n__WEAK_INLINE void __softboundcets_read_shadow_stack_metadata_store(char** endptr, int arg_num)\n__WEAK_INLINE void __softboundcets_propagate_metadata_shadow_stack_from(int from_argnum, int to_argnum)\n__WEAK_INLINE void __softboundcets_store_null_return_metadata()\n__WEAK_INLINE void __softboundcets_store_return_metadata(void* base, void* bound, size_t key, void* lock\nsystem wrappers\nmain library wrappers\nmath library wrappers\nfile library wrappers\nunistd.h wrappers\nstring related wrappers\ntime related library wrappers\n"
},
{
	"uri": "https://safersys.github.io/mm/en/sva/hwsw/securehwsw/",
	"title": "Secure HW/SW Interface",
	"tags": [],
	"description": "",
	"content": " Motivation OS memory safety research Memory safety for OS code:\n OS designs based on safe languages; Compiler techniques such as SVA-M to enforce memory safety for commodity OSs in unsafe languages; Instrumentation techniques to isolate a kernel from extensions such as device drivers;  Singularity, SPIN, JX, JavaOS, SafeDrive, and SVA-M are examples of system that enforce a safe execution environment.\nCommon asumptions of OS memory safety research Unfortunately, all these memory safety techniques (except Verve, which has very limited I/O and no MMU support) make assumptions that are routinely violated by low-level initeractions between an OS kernel and hardware, even if implemented in safe programming language. Such assumptions include:\n A static, one-to-one mapping between virtual and physical memory; An idealized processor whose state is modified only via visible program instructions; I/O operations that cannot overwrite standard memory object except input I/O targets; A protected stack modifiable only via load/store operations to local variables.  Possible attacks A buggy kernel operation might overwrite program state while it is off-processor, and that state might later be swapped in between the definition and the use of the pointer value;\nA buggy MMU mapping might remap the underlying physical memory to a different virtual page holding data of a different type;\nA buggy I/O operation might bring corrupt pointer values into memory.\nReference 1\n Memory Safety for Low-Level Software/Hardware Interactions, Usenix Security, 2009. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/os/gnu-hurd/",
	"title": "Gnu Hurd",
	"tags": [],
	"description": "",
	"content": "GNU Hurd\nReference1\n referee ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/os/freebsd/",
	"title": "Freebsd",
	"tags": [],
	"description": "",
	"content": "Reference1\n referee ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/os/minix3/",
	"title": "Minix 3",
	"tags": [],
	"description": "",
	"content": "Minix\nMinix 3\nReference1\n referee ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/cheri/cheri-domain/sandbox-loader/",
	"title": "Sandbox Loader",
	"tags": [],
	"description": "",
	"content": "// file: lib/libcheri/libcheri_sandbox_loader.c Reference1\n referee ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/cheri/cheri-domain/ccall/",
	"title": "CCall in CheriBSD",
	"tags": [],
	"description": "",
	"content": "libcheri_invoke is defined in assembly code; two versions for different ABIs respectively.\nThe Hybrid MIPS ABI (github):\n# file: lib/libcheri/mips/libcheri_invoke_hybrid.S  # # Assembly wrapper for CCall on an object-capability. Its function is to save # and restore any general-purpose and capability registers needed on either # side of CCall, but not handled by the compiler. This is done by creating an # on-stack frame which will be pointed to by $idc before CCall, and then # unwrapping it again. We rely on the compiler and CCall to sort out clearing # of registers that require it, since they have the information to do so. # # Calling conventions into libcheri_invoke: # # Registers\tDescription # $c0\tMIPS address space # $c1, $c2\tInvoked capabilities # $c3..$c10\tArgument capabilities # $c11..$c16\tCaller-save capabilities # $c17..$c26\tCallee-save capabilities # # Calling conventions implemented by CCall: # # $c1\tInvoked code capability # $c2\tInvoked data capability # $c3..$c10\tArgument capabilities; $c3 as return capability # $c11..$c16\tn/a # $c17..$c25\tn/a # $c26\tIDC # # XXXRW: Worries/TODO: # # - Floating-point registers. # - The compiler needs to handle unused argument/return registers. #  .text .global libcheri_invoke .global cheri_invoke .ent\tlibcheri_invoke libcheri_invoke: cheri_invoke: # \t# Wrap up all caller-save state suitable to be preseved by CCall and \t# restored by CReturn. This happens in two phases: \t# \t# 1. First, use the conventional stack to save as many caller-save \t# general-purpose and capability registers as possible. \t# \t# 2. Produce a value for $csp that bundles these up suitable to \t# bootstrap restoration. This will save the original $idc, $csp, \t# $sp, and $ddc. \t# \t# Then after CReturn, reverse these steps by first unwrapping $idc, \t# and then performing a more normal function return. \t# \t# The caller $csp will describe a stack fragment, which gives us a bit \t# of space to store useful things, such as $sp, that are otherwise \t# quite hard to restore (for obvious reasons). \t# \t# NB: This is still required for the hybrid ABI, unlike the \t# pure-capability ABI, because we need to save and restore $sp. \t# \t# Save callee-save general-purpose registers. \t# \t# Caller-save registers are: $s0..$s7, $gp, $sp, $s8 ($fp). \t# \t# Do also save $ra so that we can return properly. \t# \t# NB: Use 96 rather than 88 for the stack to ensure 32-byte alignment \t# for capabilities stored and loaded from it later. \t# \t# XXXRW: Possibly with the __ccall calling convention, the compiler \t# should be doing this? \t# libcheri_invoke_save_regs: daddiu\t$sp, -96 sd\t$s0, 0($sp) ... sd\t$s7, 56($sp) sd\t$gp, 64($sp) sd\t$fp, 72($sp) sd\t$ra, 80($sp) sd\t$t9, 88($sp) # \t# Save capability registers we later need to restore (that won\u0026#39;t be \t# handled by CCall for us). \t# libcheri_invoke_save_caps: cgetdefault\t$c11 daddiu\t$sp, -10*CHERICAP_SIZE csc\t$c17, $sp, 0($c11) csc\t$c18, $sp, 1*CHERICAP_SIZE($c11) ... csc\t$c26, $sp, 9*CHERICAP_SIZE($c11) # \t# Stash $sp in the offset of $c11 so that it will be saved and \t# restored by CCall. \t# \tcsetoffset\t$c11, $c11, $sp # \t# The compiler is responsible for scrubbing unused argument registers \t# (since only it has the information required to do so). CCall is \t# responsible for scrubbing all other registers. \t#  # \t# Construct link-address PCC. \t# \t# XXXRW: Do we want a CCall variant like CJALR that automatically \t# builds the desired capability? \t# \tdla\t$t0, libcheri_invoke_ccall_linkaddr cgetpcc\t$c17 csetoffset\t$c17, $c17, $t0 # \t# Invoke object capability. CCall/CReturn will save and restore $csp. \t# libcheri_invoke_ccall: CCALL($c1, $c2) libcheri_invoke_ccall_linkaddr: # \t# Unstash $sp from offset of $c11; restore $c11 offset to zero and \t# install as DDC. \t# \tcgetoffset\t$sp, $c11 csetoffset\t$c11, $c11, $zero csetdefault\t$c11 # \t# Restore capability registers from stack. \t# libcheri_invoke_restore_caps: clc\t$c17, $sp, 0($c11) clc\t$c18, $sp, 1*CHERICAP_SIZE($c11) ... clc\t$c26, $sp, 9*CHERICAP_SIZE($c11) ... # \t# CCall has conservatively cleared all non-return-value registers, and \t# so we don\u0026#39;t need to.  # \t# Restore general-purpose registers from the stack. \t# libcheri_invoke_restore_regs: ld\t$s0, 0($sp) ld\t$s1, 8($sp) ... ld\t$s7, 56($sp) ld\t$gp, 64($sp) ld\t$fp, 72($sp) ld\t$ra, 80($sp) daddiu\t$sp, 96 # \t# Return to C-language caller. \t# libcheri_invoke_return: jr\t$ra nop\t# Branch-delay slot The Pure-capability CheriABI: (github)\n# file: lib/libcheri/mips/libcheri_invoke_cabi.S  # Calling conventions into libcheri_invoke: # # Registers\tDescription # $c0\tMIPS address space # $c1, $c2\tInvoked capabilities # $c3..$c10\tArgument capabilities # $c11..$c16\tCaller-save capabilities # $c17..$c26\tCallee-save capabilities # # Calling conventions implemented by CCall: # # $c1\tInvoked code capability # $c2\tInvoked data capability # $c3..$c10\tArgument capabilities; $c3 as return capability # $c11..$c16\tn/a # $c17..$c25\tn/a # $c26\tIDC # # XXXRW: Worries/TODO: # # - Floating-point registers. # - The compiler needs to handle unused argument/return registers. #  #define LIBCHERI_INVOKE_FRAME_SIZE (11*CHERICAP_SIZE + 96)  NESTED(libcheri_invoke, LIBCHERI_INVOKE_FRAME_SIZE, _FRAME_RETURN_REG) XNESTED(cheri_invoke) # \t# Wrap up all caller-save state suitable to be preseved by CCall and \t# restored by CReturn. This happens in two phases: \t# \t# 1. First, use the conventional stack to save as many caller-save \t# general-purpose and capability registers as possible. \t# \t# 2. Produce a value for $csp that bundles these up suitable to \t# bootstrap restoration. This will save the original $idc, $csp, \t# and $ddc. \t# \t# Then after CReturn, reverse these steps by first unwrapping $idc, \t# and then performing a more normal function return. \t# \t# The caller $csp will describe a stack fragment, which gives us a bit \t# of space to store useful things that are otherwise hard to restore. \t# \t# NB: This is no longer required for the pure-capability ABI. \t# \t# Save callee-save general-purpose registers. \t# \t# Caller-save registers are: $s0..$s7, $gp, $s8 ($fp). \t# \t# NB: Use 96 rather than 88 for the stack to ensure 32-byte alignment \t# for capabilities stored and loaded from it later. \t# \t# XXXRW: Possibly with the __ccall calling convention, the compiler \t# should be doing this? \t# libcheri_invoke_save_regs: cincoffset\t$csp, $csp, -96 csd\t$s0, $zero, 0($csp) csd\t$s1, $zero, 8($csp) ... csd\t$s7, $zero, 56($csp) csd\t$gp, $zero, 64($csp) csd\t$fp, $zero, 72($csp) csd\t$ra, $zero, 80($csp) # \t# Save capability registers we later need to restore (that won\u0026#39;t be \t# handled by CCall for us). \t# libcheri_invoke_save_caps: cgetdefault\t$c12 cincoffset\t$csp, $csp, -11*CHERICAP_SIZE csc\t$c17, $zero, 0($csp) csc\t$c18, $zero, CHERICAP_SIZE($csp) ... csc\t$c26, $zero, 9*CHERICAP_SIZE($csp) csc\t$c12, $zero, 10*CHERICAP_SIZE($csp) # \t# The compiler is responsible for scrubbing unused argument registers \t# (since only it has the information required to do so). CCall is \t# responsible for scrubbing all other registers. \t#  # \t# Construct link-address PCC. \t# \t# XXXRW: Do we want a CCall variant like CJALR that automatically \t# builds the desired capability? \t# \tdla\t$t0, libcheri_invoke_ccall_linkaddr cgetpcc\t$c17 csetoffset\t$c17, $c17, $t0 # \t# Invoke object capability. CCall/CReturn will save and restore $csp. \t# libcheri_invoke_ccall: CCALL($c1, $c2) libcheri_invoke_ccall_linkaddr: # \t# Restore capability registers from stack. \t# libcheri_invoke_restore_caps: clc\t$c17, $zero, 0($csp) clc\t$c18, $zero, CHERICAP_SIZE($csp) ... clc\t$c26, $zero, 9*CHERICAP_SIZE($csp) clc\t$c12, $zero, 10*CHERICAP_SIZE($csp) csetdefault\t$c12 ... # Restore general-purpose registers from the stack. \t# \t# XXXRW: Possibly with the __ccall calling convention, the compiler \t# should be doing this? \t# libcheri_invoke_restore_regs: cld\t$s0, $zero, 0($csp) cld\t$s1, $zero, 8($csp) cld\t$s2, $zero, 16($csp) cld\t$s3, $zero, 24($csp) cld\t$s4, $zero, 32($csp) cld\t$s5, $zero, 40($csp) cld\t$s6, $zero, 48($csp) cld\t$s7, $zero, 56($csp) cld\t$gp, $zero, 64($csp) cld\t$fp, $zero, 72($csp) cld\t$ra, $zero, 80($csp) cincoffset\t$csp, $csp, 96 # \t# Return to C-language caller. \t# libcheri_invoke_return: cjr\t$c17 nop\t# Branch-delay slot  END(libcheri_invoke) CCALL is defined as a macro wrapper for ccall in CheriBSD, source code: (github)\n// file: sys/mips/include/cheriasm.h  #define CCALL(cb, cd)\t\\ \t.set push;\t\\ .set noreorder;\t\\ ccall cb, cd, 1;\t\\ nop; /* Fill branch delay slot for old harware*/\t\\ .set pop; The libcheri_invoke_ccall after compilation:\n128-bit mode are the same: Reference1\n referee ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/cheri/cheri-kernel/memcopy/",
	"title": "Copying Memory",
	"tags": [],
	"description": "",
	"content": "The kernel\u0026rsquo;s bcopy, memcpy, copyin, and copyout routines are capability-unaware and will not preserve tag bits.\nNew cheri_bcopy, cheri_memcpy, copyincap, and copyoutcap are used in situations where preserving tags is desirable \u0026ndash; such as copying in or out of CHERI trusted stacks.\nClearing tag bits across conventional IPC, system call arguments, and so on is important in preventing the accidental leaking of rights between address space where only data copies are intended.\n"
},
{
	"uri": "https://safersys.github.io/mm/en/cheri/cheri-kernel/signal/",
	"title": "Signals in Sandboxed Code",
	"tags": [],
	"description": "",
	"content": " Questions/Proposals  Can a signal handler in userspace overwrite the trusted stack?  Umodified signal handling:\n a regular MIPS process CHERI-aware process that does not make use of sandboxing (protection domains).  Signal in a sandbox When a signal must be delivered to the target thread and the code is executing in a sandbox of that thread. Then sandbox code\u0026rsquo;s stack cannot be used for signal handling. Kernel will have different operations in the following situations 1:\nSandboxed code, trap signal arises, no registered signal handler \u0026ndash; unwind Automatic trusted-stack unwinding using cheri_stack_unwind, returning control to the caller. Assumptions:\n a thread triggers a trap signal due to an exception, and the signal is uncaught, and signal is tagged as SIGPROP_SBUNWIND  In this case, \u0026lsquo;sandboxed code\u0026rsquo; means that one or more frames are present on the trusted stack, rather than that the current execution context lacks privilege.\nSandboxed code, registered signal handler, no alternative signal stack \u0026ndash; terminate If handler registered, then we must install a suitable signal-handling context (typically, ambient authority).\nHowever, we cannot trust the stack in the sandbox context, thus we will instead use the UNIX alternative signal stack.\nIf one is not defined for the thread, the process will be terminated as there is no safe way to handle the signal.\nIn this case and the following case, \u0026lsquo;sandboxed code\u0026rsquo; means that the current executing context does not have ambient authority \u0026ndash; i.e., that it cannot invoke system calls.\nSandboxed code, registered signal handler, alternative signal stack \u0026ndash; deliver If an alternative signal stack is configured, then ambient authority will be temporarily restored and signal delivery will take place no the alternative stack.\nCurrently, the kernel installs ambient-authority capabilities in PCC, C0, C11 (stack capability), and IDC prior to executing the signal handler.\nWhen signal handler returns, the kernel will restore capability-register state saved on the stack. This will release ambient authority if the saved (and possibly rewritten) register does not hold it.\nConfiguring an alternative signal stack requires that a signal stack be allocated and registered with signalstack and the signal handler be registered to use it with the SA_ONSTACK flag in sigaction1.\nImmature ABI Up to 2015, programmer\u0026rsquo;s guide:\nUser code can access the saved capability-coprocessor register values, including the capability-cause register (cf_capcause), via a struct cheriframe pointed to by the uc_mcontext.mc_cp2state pointer in the context_t argument to the signal handler.\nThe signal handler should check that the mc_cp2state pointer is non-NULL, and the correponding uc_mcontext.mc_cp2state_len field is equal to sizeof(struct cheriframe), before proceeding.\nThis ABI is currently immature, as the same daa structure is used both for kernel\u0026rsquo;s internal representation of the capability and its on-stack representation; this will change in the future version of CheriBSD.\nTrusted stack writable for signal handlers As ambient authority is installed, signal handlers are also able to rewrite the trusted stack1. This allows more mature handling of exceptions within sandboxes or other invoked contexts \u0026ndash; for example, unwinding of the trusted stack, garbage collection activitites, etc. In CheriBSD\u0026rsquo;s cheritest tool, this is used to handle timeouts trigged by SIGALRM, terminating sandboxed if they overrun their execution-time limit, for example.\nA key design choice is that signal handlers are not invoked by a CCall-like mechanism. This is done for several reasons, not least that we wish to be able to handle trusted-stack overflow in userspace via a signal handler. Great care must be exercised in writing signal handlers that execute with ambient authority in order to not leak privileges to a non-ambient context2.\n CHERI programmer\u0026rsquo;s guide, TR-877, 2015. ↩ Who can write signal handlers? ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/cheri/cheri-kernel/trusted-stack/",
	"title": "Trusted Stack",
	"tags": [],
	"description": "",
	"content": "References:\n[1] CHERI programmer\u0026rsquo;s guide, UCAM-CL-TR-877 Chapter 8.4, 2015.\nOne trusted stack for each thread: pcb_cheristack.\nInitialized to empty when first thread in a process is created.\nStack updates/inspections in the following situations:\n CCall exception CReturn exception CHERI_GET_STACK via sysarch system call CHERI_SET_STACK via sysarch system call cheri_stack_unwind: if a signal is delivered to a thread that is executing sandboxed code, and suitable signal-handling configuration has not been set up to safely receive the delivered signal, then for certian signals the kernel will automatically unwind the stack back to the caller of the sandbox. show cheristack command in DDB.  "
},
{
	"uri": "https://safersys.github.io/mm/en/cheri/cheri-kernel/context-switch/",
	"title": "CheriBSD Context Switch",
	"tags": [],
	"description": "",
	"content": " References:\n[1] CHERI programmer\u0026rsquo;s guide, chapter 8.2, UCAM-CL-TR-877, 2015.\nCapability state save/restore for each thread and domain inside.\n CheriBSD extends the kernel\u0026rsquo;s support for context management and switching to provide each user thread with its own capability-register file. This allows each thread to have its own complete capability state, compatible with the idea that capabilities are compiler-managed.\n Context switching to kernel in 3 ways:\n an initial saving of the userspace $PCC and C0 performed by the hardware and low-level exception handling code; a more complete capability register context save and restore when transitioning from a low-level exception handler to kernel C code; finally, saving and restoring of a capability-register-file subset during voluntary kernel context switches.  PCB struct extended with CHERI state Extends thread control block, pcb, with four new fields:\n pcb_cheriframe: userspace CHERI registers; pcb_cheristack: the CHERI trusted stack; pcb_cheri_signal: signal handling context to install when a signal is delivered within a sandbox; pcb_cherik_frame: caller-save registers across a kernel voluntary context switch.  Kernel state \u0026ndash; no capability 2015 programmer\u0026rsquo;s guide:\n Kernel itself makes only minor use of capabilities; Kernel is not currently compiled with a capability-aware compiler; kernel threads do not have full capability-register-file state in their own PCBs.   Currently, CheriBSD maintains a \u0026lsquo;full\u0026rsquo; CHERI capability-register context only for userspace, not the kernel, as the kernel is compiled by a CHERI-unaware compiler. Instead, the kernel uses fixed global values for C0 and PCC, and its context switches maintain two capability registers for use in setting up userspace state, performing capability-aware memory copies, etc: C11 and C12.\n Context-switching philosophy Fast-exception handlers for exception delivery -\u0026gt; full userspace context saving for a full C function execution.\nMIPS: use (K0, K1) as reserved exception handling registers;\nCHERI: saves the userspace C0 in KR2C; then installs the kernel\u0026rsquo;s own C0.\nLazy context-switching of capability-coprocessor is not currently implemented, requiring a full save and restore of the capability register file when entering kernel C code.\nPCB setup and state changes PCB CHERI state initialization: execve -\u0026gt; exec_setregs -\u0026gt;\n cheri_exec_setregs: sets up the first thread\u0026rsquo;s live and signal-handling C0, C11 (stack), IDC, and PCC registers for ambient authority; cheri_stack_init: initialize an empty trusted stack.  MIPS machine dependent state for a new thread: cpu_set_upcall -\u0026gt;\n cheri_context_copy: register context; literal cheri_signal_copy: signal delivery context; cheri_stack_copy: copy the current trusted stack the the new thread. Desiable or should get a fresh new trusted stack?  fork system call, implemented in MIPS machine depedent cpu_fork-\u0026gt; cheri_context_copy; cheri_signal_copy; cheri_stack_copy.\n4 types of context switches  Low-level exception enter/return. CHERI_EXCEPTION_ETNER, CHERI_EXCEPTION_RETURN;\n User-to-kernel switch: SAVE_U_PCB_CHERIFRAME, RESTORE_U_PCB_CHERIFRAME. This occurs if an excecption deliverd to user code cannot be satisfied without entering C code \u0026ndash; e.g. to process a full VM fault rather than just a TLB miss that a low-level assembly handler can resolve.\n Kernel involuntary switch: an exception preempts the kernel istelf (e.g. a kernel TLB miss or interrupt), the full MIPS general-purpose state will be saved by MipsKernGenException, but only C11 and C12 will be preserved, as the kernel currently use only these capability registers. In the future, this code will need to preserve a full kernel CHERI frame.\n Kernel voluntary switch: If a kernel thread sleeps (perhaps due to blocking on a mutex or waiting on I/O), then a voluntary context switch via cpu_switch, which in turn will call SAVE_U_PCB_CHERIKFRAME and RESTORE_U_PCB_CHERIKFRAME to save and restore callersave registers in the PCB.\n  Questions/Proposals compiler-manged capabilities: for compiler to be able to manage capabilities, each thread must have its own complete capability state. Extending this idea, if compiler could manage all the context switching states of a thread, we don\u0026rsquo;t need an operating system anymore, yes? So if entire system, all applications, resides in the same address space, then, we can get ride of operating system to do context switching and all work will be done by compilers, automatically. Reasonable?\nkernel code compilation: To use capability inside kernel, we must use capability-aware compiler to compile kernel code. However, currently not done yet (2015, programmer\u0026rsquo;s guide). What is the main challenge here?\n"
},
{
	"uri": "https://safersys.github.io/mm/en/cheri/cheri-kernel/kernel-changes/",
	"title": "Kernel Change List",
	"tags": [],
	"description": "",
	"content": " References:\n[1] CHERI programmer\u0026rsquo;s guide, UCAM-CL-TR-877, 2015.\nOverview  booting: enable capability coprocessor. per-thread TCB:  a saved capability register file; a per-thread trusted stack  context-switching: save/restore capability register file for userspace. kernel debugger: print capability register file and other CHERI-related info. virtual-memory subsystem:  anonymous (swap-backed) memory objects: memory tags preserved; memory mappings are permitted to set the CHERI TLB bits enabling tagged loads and stores. other objects not yet to preserve tags.  kernel memory copying:  new routines preserve tags; selectively used: in copying register files and explicit tag-preserving copies; majority of kernel memory copies are not tag-preserving.  system call permission:\n rejects whose $PCC register does not have CHERI_PERM_SYSCALL user-defined permission bit, preventing sandboxes from directly invoking system services; sandbox must invoke a system class that is authorized to invoke system calls; should also have new system calls that does not need for interposition \u0026ndash; similar to the behavior of Capsicum.  ccall and creturn fast exception handers:\n unseal invoked object; push the caller state to trusted stack; retore it on return; return to caller if fault occurs.  ktrace facility: allow object invocation/return to be traced.\n cap faults:\n fault in userspace deliver as signals, extending signal trap frame to include capability registers; allows userspace software ( in particular, language runtimes) to catch and handle software protection faults.  extended to allow processes to export class, method, and object statistics.\n supports CheriABI: a new ABI and system call interface:\n all pointers passed to and from the kernel are implemented as capabilities; allows userspace processes to execute pure-capability-ABI binaries that have no dependence on conventional MIPS pointers.   Source code src/sys/mips/cheri/ and src/sys/mips/include contains the majority of CHERI-specific code:\n- coprocessor 2 initialization - context management  headers  cheri.h: C-language definitions relating to capabilities\n kernel-only context structures: cheri_kframe, cheri_signal; kernel/user shared structures: cheri_frame, cheri_stack; macro wrappers for inline assembly are provided for CHERI-aware software implemented via CHERI-unaware C, such as the kernel.  cheriasm.h: definitions for CHERI-aware assembly\n kernel/userspace deinitions: CHERI register names kernel-specific code used in exception handling  cheric.h: compiler builtin wrapper for register access, such as cheri_getbase(), cheri_andperm(). This is used only in userpsace due to dependencies on CHERI-aware Clang/LLVM.\n cherireg.h: C macros suitable for use in both C and assembly that specify low-level CHERI constants, such as permission-mask values. For both kernel and userspace.\n sys/sys/cheri_serial.h: provides a structure and definitions supporting serialization of capabilities independent of their size and micro-architectural details.\n  Source files ccall.S: fast exception handlers for ccall and creturn. Errors go to a regular MipsUserGenException hander.\nccall_ktrace.S: a slow path exception handlers used to trace ccall and creturn invocations.\ncheri.c: majority of CHERI-specific C code including:\n debugging features; sysctls; initializaitoni for the capability state of threads/processes; handling of fork; portion of signal handling; exception logging; system call authorization.   cheri_bcopy.S: CHERI version of memcpy and bcopy\n suitable for use throughout the kernel copyin and copyout do not use them? [ch 8.1, p49]  cheri_debug.c: CHERI commands for in-kenrel debugger.\ncheri_exception.c: reporting CHERI exceptions and registers on the system console.\ncheri_signal.c: CHERI signal handling infrastructure.\ncheri_stack.c: CHERI trusted-stack initialization, copying, and unwinding, and sysarch system calls to get/set current trusted stack.\ncheri_syscall.c: CHERI related system-call infrastructure.\ncheriabi_machdep.c: ISA dependent CheriABI support including\n system call vector declaration; argument parsing; return handling; signal handling; process memory initialization.  sys/compat/cheriabit/* CheriABI ISA-independent implementation. The implementation is modelled on the support for 32-bit binaries in sys/compat/freebsd32.\nQuestions Todo list:\n in cheri.h: \u0026ldquo;Macro wrappers for inline assembly are provided for CHERI-aware software implemented via CHERI-unaware C, such as the kernel\u0026rdquo;, what is this? How does the CHERI-aware and CHERI-unaware code interface each other here?  Lele: See CheriABI, which defines how userspace (full capability) interfaces with kernel that has partial capability. \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;   "
},
{
	"uri": "https://safersys.github.io/mm/en/cheri/cheri-domain/ccall-tests/",
	"title": "ccall Tests",
	"tags": [],
	"description": "",
	"content": " References:\n[1]\nStack Underflow /* * Perform a return without a corresponding invocation, to underflow the * trusted stack. */ void test_sandbox_trustedstack_underflow(const struct cheri_test *ctp __unused) { struct cheri_object returncap; void * __capability codecap /* currently ignored: asm (\u0026#34;$c1\u0026#34;) */; void * __capability datacap /* currently ignored: asm (\u0026#34;$c2\u0026#34;) */; returncap = libcheri_make_sealed_return_object(); codecap = returncap.co_codecap; datacap = returncap.co_datacap; /* * TODO: the branch delay slot has been removed. We can remove the nop * once we no longer expect to run on older bitfiles */ __asm__ __volatile__ (\u0026#34;ccall %0, %1, 1\\n\\tnop\u0026#34; : : \u0026#34;C\u0026#34;(codecap), \u0026#34;C\u0026#34;(datacap)); cheritest_failure_errx(\u0026#34;continued after attempted CReturn\u0026#34;); } "
},
{
	"uri": "https://safersys.github.io/mm/en/cheri/cheri-domain/ssh/",
	"title": "Ssh",
	"tags": [],
	"description": "",
	"content": "References:\n[1]\n"
},
{
	"uri": "https://safersys.github.io/mm/en/cheri/cheri-kernel/kernel-cap/",
	"title": "Kernel Cap",
	"tags": [],
	"description": "",
	"content": "2015 programmer\u0026rsquo;s guide:\n Kernel itself makes only minor use of capabilities; Kernel is not currently compiled with a capability-aware compiler; kernel threads do not have full capability-register-file state in their own PCBs.  A hardcoded kernel capability1:\n/* * Definition for a highly privileged kernel capability able to name the * entire address space, and suitable to derive all other kernel-related * capabilities from, including sealing capabilities. */ #define\tCHERI_CAP_KERN_PERMS\t\\ \t(CHERI_PERMS_SWALL | CHERI_PERMS_HWALL) #define\tCHERI_CAP_KERN_BASE\t0x0 #define\tCHERI_CAP_KERN_LENGTH\t0xffffffffffffffff #define\tCHERI_CAP_KERN_OFFSET\t0x0  cherireg.h ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/cheri/intro/motivation/",
	"title": "Motivations",
	"tags": [],
	"description": "",
	"content": " ISA v5, p14:\nUbiquitous computing changes threat models  Dramatic changes in threat models, resulting from ubiquitous connectivity and pervasive uses of computer technology in many diverse and widely used applications such as wireless mobile devices, automobiles, and critical infrastructure.\n Endless \u0026ldquo;patch and pray\u0026rdquo; calls for architectural \u0026lsquo;immunity\u0026rsquo;  An extended \u0026ldquo;arm race\u0026rdquo; of inevitable vulnerabilities and novel new attack mechanisms has led to a cycle of \u0026ldquo;patch and pray\u0026rdquo;. \u0026hellip; a strong need for underlying architectures that offer stronger inherent immunity to attackers, minimize gained attack surfaces, and increase the work factor for attackers.\n Mature tool-chains bring new opportunities  New opportunities for research into (and possible revisions of) hardware-software interfaces, brought about by programmable hardware (especially FPGA soft cores) and complete open-source software stacks such as FreeBSD and LLVM.\n Similar hardware innovation already applied for performance/power purpose  An increasing trend towards exposing inherent hardware parallelism through virtual machines and explicit software multi-programming, and an increasing awareness of information flow for reasons of power and performance that may align well with the requirements of security. what is this mean, examples?\n PL advances brings new opportunity  Emerging advances in programming languages, such as the ability to map language structures into protection parameters to more easily express and implement various policies. what is this? examples?\n \u0026ndash;\u0026gt; Map language structures into protectin parameters?\nDiverse hardware architectures flourished  Reaching the tail end of a \u0026ldquo;compatibility at all costs\u0026rdquo; trend in CPU design, due to proximity to physical limits on clock rates and trends towards heterogeneous and distributed computing. While \u0026ldquo;Wintel\u0026rdquo; remains entrenched on the desktop, mobile systems \u0026ndash; such as phones and tablet PCs, as well as appliances and embedded devices \u0026ndash; are much more divers, running on a wide variety of instruction set architectures (especially ARM and MIPS).\n Various new OSes proved success of new security models  Likewise, new diversity in operating systems has arisen, in which commercial products such as Apple\u0026rsquo;s iOS and Google\u0026rsquo;s Android extend open-source systems such as FreeBSD, Mach, and Linux. These new platforms abandon many traditional constraints, requiring that rewritten applications conform to new security models, programming languages, hardware architectures, and user-input modalities.\n Capsicum is a success for hybrid capability system  Development of hybrid capability-system models, such as Capsicum, that integrate capability-system design tenets into current operating-system and language designs. With CHERI, we are transposing this design philosophy into the instruction-set architecture. Hybrid design is a key differentiator from prior capability-system processor designs that have typically required ground-up software-architecture redesign and reimplementation.\n Modern era allows deep hw/sw stack changes  Significant changes in the combination of hardware, software, and formal methods to enhance assurance now make possible the development of trustworthy system architectures that previously were simply too far ahead of their times.\n Client-server model evolved to similar complex client \u0026amp; server Client-server and cloud computing:\n even thin clients are not thin in most practical senses: as with client-server computer systems, they built from commodity operating system kernels, hundreds of user-space libraries, window servers, language runtime environments, and web browsers, which themselves include scripting language interpreters, virtual machines, and rendering engines.\nBoth server and embedded systems likewise depends on complex (and quite similar) software stacks. All require confluence of competing interests, representing multiple site, tasks, and end users in unified computing environments.\n Most software stacks have TCB in C  Whereas higher-layer applications are able to run on top of type-safe or constrained execution environments, such as JavaScript interpreters, lower layers of the system must provide the link to actual execution on hardware. As a result, almost all such systems are written in the C programming language; collectively, this Trusted Computing Base (TCB) consists of many tens of millions of lines of trusted (but not trustworthy) C and C++ code. Coarse hardware, OS, and language security models mean that much of this code is security sensitive: a single flaw, such as an errant NULL pointer dereference in the kernel, can expose all rights held by users of a system to an attacker or to malware.\n Inevitable software vulnerabilities calls for privilege separation  Even if low-level escalation techniques (such as arbitrary code injection and code reuse attacks) could be prevented, logical erros and supply-chain attacks will necessarily persist.\n.. compartmentalizing applications into components executed in isolated sandboxes can mitigate exploited vulnerabilities (sometimes referred to as privilege separation).\n Compartmentalization problem calls for hardware support Microkernel is abondened due to its limits applicability  Historically, compartmentalization of TCB components such as operating system kernels and central system services has caused significant difficulty for software developers \u0026ndash; which limits its applicability for large-scale, real-world applications, and leads to the abandonment of promissing research such as 1990s microkernel projects.\n OpenSSH, Chromium, Capsicum success but has coarse grain  A recent resurgence of compartmentalization, applied in userspace to applications such as OpenSSH and Chromium, and more recently in our own Capsicum project, has been motivated by a critical security need; however, it has seen success only at very coarse separation granularity due to the challenges involved.\n Performance is sacrificed Domain switching results in TLB overflowing, especially with large page table sizes.\n The TLB footprint of fine-grained, compartmentalized software increases with the product of in-flight security domains and objects due to TLB aliasing.\n Programmability is sacrificed Intra address space communication: pass a pointer; Inter address space communication:\n message passing, distributed programming model RPC systems, not suit for TCB  Bittau, sthreads, an OS primitive that tightly couples UNIX processes via shared memory associated with data types \u0026ndash; a promising separation approach constrained by the realities of current CPU design.   Security is sacrificed, finally "
},
{
	"uri": "https://safersys.github.io/mm/en/cheri/cheri-domain/hello/",
	"title": "Examples of Cheri Object Capabilities",
	"tags": [],
	"description": "",
	"content": " References:\n[1]\nCode is derived from cheritest_ccall.c.\nExample 1: static sandboxes The first example is a hand-crafted, minimalist sandbox that don\u0026rsquo;t even have stacks: no local data, just contain one instruction creturn. For stacks, see libcheri examples\nFor code capability, need a function pointer as base, and another function pointer as the boundary enclosing the last instruction. The following example have function named sandbox_creturn and ends on sandbox_creturn_end:\n.text .type sandbox_creturn,@function .global sandbox_creturn .ent sandbox_creturn sandbox_creturn: creturn .end sandbox_creturn .global sandbox_creturn_end sandbox_creturn_end: .size sandbox_creturn, sandbox_creturn_end - sandbox_creturn .size sandbox_creturn_end, 0 This is the man page for assembler directives and MIPS directives.\nData capability is set to have the same range (base and bounds) as code capability. The different permission on the code and data capabilities would limit how they can be used.\nMain testing code as following. It will create a pair of sealed code and data capabilities; then define them as an cheri_object; finally invoke it via libcheri_invoke:\nstatic void * __capability sandbox_creturn_sealcap; static void * __capability sandbox_creturn_codecap; static void * __capability sandbox_creturn_datacap; struct cheri_object co; /* * Create sealing, sealed code, and sealed data capabilities for each * of the three classes used in these tests. */ sandbox_creturn_sealcap = libcheri_type_alloc(); sandbox_creturn_codecap = cheri_seal( codecap_create(\u0026amp;sandbox_creturn, \u0026amp;sandbox_creturn_end), sandbox_creturn_sealcap); sandbox_creturn_datacap = cheri_seal( datacap_create(\u0026amp;sandbox_creturn, \u0026amp;sandbox_creturn_end), sandbox_creturn_sealcap); /* * CCall code that will immediately CReturn. */ co.co_codecap = sandbox_creturn_codecap; co.co_datacap = sandbox_creturn_datacap; (void)libcheri_invoke(co, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL); Manually create code and data capability pair by codecap_create() and datacap_create().\nThe definition of codecap_create():\nstatic void * __capability codecap_create(void (*sandbox_base)(void), void *sandbox_end) { void * __capability codecap; #ifdef __CHERI_PURE_CAPABILITY__ \t(void)sandbox_end; codecap = cheri_andperm(sandbox_base, CHERI_PERM_GLOBAL | CHERI_PERM_LOAD | CHERI_PERM_EXECUTE); #else \tcodecap = cheri_codeptrperm(sandbox_base, (size_t)sandbox_end - (size_t)sandbox_base, CHERI_PERM_GLOBAL | CHERI_PERM_LOAD | CHERI_PERM_EXECUTE); #endif \treturn (codecap); } Definition of datacap_create():\nstatic void * __capability datacap_create(void *sandbox_base, void *sandbox_end) { void * __capability datacap; #ifdef __CHERI_PURE_CAPABILITY__ \t(void)sandbox_end; datacap = cheri_andperm(sandbox_base, CHERI_PERM_GLOBAL | CHERI_PERM_LOAD | CHERI_PERM_STORE | CHERI_PERM_LOAD_CAP | CHERI_PERM_STORE_CAP | CHERI_PERM_STORE_LOCAL_CAP); #else \tdatacap = cheri_ptrperm(sandbox_base, (size_t)sandbox_end - (size_t)sandbox_base, CHERI_PERM_GLOBAL | CHERI_PERM_LOAD | CHERI_PERM_STORE | CHERI_PERM_LOAD_CAP | CHERI_PERM_STORE_CAP | CHERI_PERM_STORE_LOCAL_CAP); #endif \treturn (datacap); } Example 2: ccall hello world Annotations:\n cheri_ccall: compiler will replaces calls to it with specially crafted calls to cheriinvoke, with method number (identified by a gplobal variable that is initialised by the sandbox loader) in correct register. This annotation provides two declarations of the function:\n cheri_method_suffix: specifies a suffix that takes an explicit CHERI class argument. cheri_method_class: specifies a global variable that automatically sets the class (code and data capability) argument.  cheri_ccallee: will use the ccall calling convention. The compile will zero any return registers. Allow functions to be declared that are usable both inside and between compartments.\n Functions with ccall calling convention have two extra capability argument registers, $c1 and $c2, which contains the code and data capabilities, an extra integer argument register, $v0, which contains the method number. These are not exposed to functions marked as using the ccallee calling convention, which accept the normal calling convention\u0026rsquo;s argument registers.   C code // The `invoke_cheri_system_helloworld()` will invoke hello world in a sandbox:  // file: bin/cheritest/cheritest_libcheri.c void test_sandbox_cs_helloworld(const struct cheri_test *ctp __unused) { register_t v; v = invoke_cheri_system_helloworld(); if (v \u0026lt; 0) cheritest_failure_errx(\u0026#34;Sandbox returned %jd\u0026#34;, (intmax_t)v); else cheritest_success(); } // The following is the declaration of the call gate of // `invoke_cheri_system_helloworld()`  // file: libexec/cheritest-helper/cheritest-helper.h struct cheri_object; BEGIN_CAPABILITIES CHERITEST_CCALL int\tinvoke_cheri_system_helloworld(void); END_CAPABILITIES // file: libexec/cheritest-helper/cheritest-helper.c extern struct cheri_object cheritest; #ifdef CHERITEST_INTERNAL #define\tCHERITEST_CCALL\t\\  __attribute__((cheri_ccallee))\t\\ __attribute__((cheri_method_class(cheritest))) #else #define\tCHERITEST_CCALL\t\\  __attribute__((cheri_ccall))\t\\ __attribute__((cheri_method_suffix(\u0026#34;_cap\u0026#34;)))\t\\ __attribute__((cheri_method_class(cheritest))) #endif  // The following is the definition of the call gate of // `invoke_cheri_system_helloworld()` The assembly code for test_sandbox_cs_helloworld():\n/* file: cheritest.s , commit: def7a422bf */ 000000000003c8a8 test_sandbox_cs_helloworld: 3c8a8: 67 bd ff e0 daddiu $sp, $sp, -32 3c8ac: ff bf 00 18 sd $ra, 24($sp) 3c8b0: ff be 00 10 sd $fp, 16($sp) 3c8b4: ff bc 00 08 sd $gp, 8($sp) 3c8b8: 03 a0 f0 25 move $fp, $sp 3c8bc: 3c 01 00 11 lui $1, 17 3c8c0: 00 39 08 2d daddu $1, $1, $25 3c8c4: 64 3c f7 58 daddiu $gp, $1, -2216 3c8c8: df 81 89 20 ld $1, -30432($gp) 3c8cc: df 83 87 80 ld $3, -30848($gp) 3c8d0: dc 22 00 00 ld $2, 0($1) 3c8d4: d8 20 18 00 clc $c1, $3, 0($ddc) 3c8d8: 64 61 00 20 daddiu $1, $3, 32 3c8dc: d8 40 08 00 clc $c2, $1, 0($ddc) 3c8e0: df 99 87 88 ld $25, -30840($gp) 3c8e4: 48 03 02 bf cgetnull $c3 3c8e8: 48 04 02 bf cgetnull $c4 3c8ec: 48 05 02 bf cgetnull $c5 3c8f0: 48 06 02 bf cgetnull $c6 3c8f4: 48 07 02 bf cgetnull $c7 3c8f8: 48 08 02 bf cgetnull $c8 3c8fc: 48 09 02 bf cgetnull $c9 3c900: 48 0a 02 bf cgetnull $c10 3c904: 64 04 00 00 daddiu $4, $zero, 0 3c908: 64 05 00 00 daddiu $5, $zero, 0 3c90c: 64 06 00 00 daddiu $6, $zero, 0 3c910: 64 07 00 00 daddiu $7, $zero, 0 3c914: 64 08 00 00 daddiu $8, $zero, 0 3c918: 64 09 00 00 daddiu $9, $zero, 0 3c91c: 64 0a 00 00 daddiu $10, $zero, 0 3c920: 03 20 f8 09 jalr $25 3c924: 64 0b 00 00 daddiu $11, $zero, 0 3c928: 04 41 00 06 bgez $2, 28 \u0026lt;test_sandbox_cs_helloworld+0x9c\u0026gt; 3c92c: 00 00 00 00 nop 3c930: df 81 80 c8 ld $1, -32568($gp) 3c934: 00 02 28 00 sll $5, $2, 0 3c938: df 99 84 90 ld $25, -31600($gp) 3c93c: 03 20 f8 09 jalr $25 3c940: 64 24 3b ce daddiu $4, $1, 15310 3c944: df 99 84 88 ld $25, -31608($gp) 3c948: 03 20 f8 09 jalr $25 3c94c: 00 00 00 00 nop Another disassembly from cheriabitest:\n/* file: cheriabitest.s, commit: def7a422bf*/ 0000000120087310 test_sandbox_cs_helloworld: 120087310: 4a 6b 5f 80 cincoffset $c11, $c11, -128 120087314: fb 0b 00 06 csc $c24, $zero, 96($c11) 120087318: fa 4b 00 04 csc $c18, $zero, 64($c11) 12008731c: fa 2b 00 02 csc $c17, $zero, 32($c11) 120087320: 48 18 58 11 cincoffset $c24, $c11, $zero 120087324: 3c 01 00 14 lui $1, 20 120087328: 64 21 e1 30 daddiu $1, $1, -7888 12008732c: 48 12 60 51 cincoffset $c18, $c12, $1 120087330: 74 32 08 60 clcbi $c1, 34304($c18) 120087334: 74 52 03 5a clcbi $c2, 13728($c18) 120087338: c8 41 00 03 cld $2, $zero, 0($c1) 12008733c: d8 22 00 00 clc $c1, $zero, 0($c2) 120087340: d8 42 00 02 clc $c2, $zero, 32($c2) 120087344: 75 92 03 5c clcbi $c12, 13760($c18) 120087348: 48 03 02 bf cgetnull $c3 12008734c: 48 04 02 bf cgetnull $c4 120087350: 48 05 02 bf cgetnull $c5 120087354: 48 06 02 bf cgetnull $c6 120087358: 48 07 02 bf cgetnull $c7 12008735c: 48 08 02 bf cgetnull $c8 120087360: 48 09 02 bf cgetnull $c9 120087364: 48 0a 02 bf cgetnull $c10 120087368: 64 04 00 00 daddiu $4, $zero, 0 12008736c: 64 05 00 00 daddiu $5, $zero, 0 120087370: 64 06 00 00 daddiu $6, $zero, 0 120087374: 64 07 00 00 daddiu $7, $zero, 0 120087378: 64 08 00 00 daddiu $8, $zero, 0 12008737c: 64 09 00 00 daddiu $9, $zero, 0 120087380: 64 0a 00 00 daddiu $10, $zero, 0 120087384: 48 11 63 3f cjalr $c12, $c17 120087388: 64 0b 00 00 daddiu $11, $zero, 0 12008738c: 04 41 00 09 bgez $2, 40 \u0026lt;test_sandbox_cs_helloworld+0xa4\u0026gt; 120087390: 00 00 00 00 nop 120087394: 00 02 08 00 sll $1, $2, 0 120087398: e8 2b 00 03 csd $1, $zero, 0($c11) 12008739c: 4a 81 58 08 csetbounds $c1, $c11, 8 1200873a0: 34 01 ff d7 ori $1, $zero, 65495 1200873a4: 74 72 08 54 clcbi $c3, 34112($c18) 1200873a8: 75 92 01 92 clcbi $c12, 6432($c18) 1200873ac: 48 11 63 3f cjalr $c12, $c17 1200873b0: 48 0d 08 4d candperm $c13, $c1, $1 1200873b4: 75 92 01 8e clcbi $c12, 6368($c18) 1200873b8: 48 11 63 3f cjalr $c12, $c17 1200873bc: 00 00 00 00 nop  Example 3: libcheri sandboxes "
},
{
	"uri": "https://safersys.github.io/mm/en/os/linux/execve/",
	"title": "execve",
	"tags": [],
	"description": "",
	"content": " References:\n[1] How programs get run. LWN.net, 2015. [link1, link2]\nLoad ELF binary In fs/binfmt_elf.c: load_elf_binary(): examining ELF header.\nflush_old_exec(): clears up state in kernel that refers to the previous program.\nsetup_new_exec(): set up kernel\u0026rsquo;s internal state for the new program. flush_signal_handlers() sets up the signal handlers for the new program. do_close_on_exec() closes all of the old program\u0026rsquo;s file descriptors.\nSet up the virtual memory of the new program. The highest address for the stack is moved downward by a random offset. create_elf_tables()\n"
},
{
	"uri": "https://safersys.github.io/mm/en/sva/dsa/",
	"title": "Data Structure Analysis",
	"tags": [],
	"description": "",
	"content": " Q \u0026amp; A  How many incomplete nodes during evaluation?  Ans: Not much, but most program exists. Including the collapsed nodes, ranging from 1.2% ~ 88.5%. See evaluation: type inference result    Basics Flow sensitive1: takes into account the order of statements in a program.\nPath Sensitive: takes into account the branch conditions.\nContext Sensitive: names objects by entire acyclic call paths. A callee will return to its single call site instead of all possible call sites.\nDisjoint Data Structure Analysis A pointer analysis algorithm\n Identify disjoint instance of pointer-based data structure \u0026amp; their lifetimes. Identified by computing a point-to-graph: Data Structure Graph.  Data Structure Graph DS Graph is a field-sensitive representation of the point-to information. It is a directed multi-graph, where:\n one graph for each function. Except where all functions share a common graph.\n different nodes represent distinct memory objects.\n  One DS node = \u0026lt; $ \\tau $, F, M, A, G \u0026gt;:\n $ \\tau $: program defined type, or $\\perp$ for unknown type; F: an array of fields; M: memory class, $\\subseteq$ { Heap, Stack, Global, Unknown}; A: true if nodes includes an array; G: set of globals in the struct if G$\\in$ M.  One DS edge: \u0026lt; s, $f_s$, t, $f_t$ \u0026gt;:\n s, t: Two nodes; $f_s$, $f_t$: fields of s, t.  Full context sensitive It names heap objects by entire acyclic call paths (which we refer to as \u0026ldquo;full heap cloning\u0026rdquo;), which allows distinguishing heap object allocated/destroyed by common function calls (eg. lib functions).\nUnification-style analysis A pointer field at a node has only one outgoing DS edge, i.e. all targets of the pointer are merged into a single node.\nAnalysis is flow insensitive: does not take into account the order of statements.\nCollapsed Nodes Collapsed nodes are field-insensitive, represent objects that has incompatible types, tagged as \u0026ldquo;unknown type\u0026rdquo;.\n(2005LattnerPhD2) If operations using incompatible types are found, the type for the node is treated as unsized array of bytes (T(n)=void *), and the fields and edges of the node are \u0026ldquo;collapsed\u0026rdquo; into a single field with at most one outgoing edge. The node is marked as \u0026lsquo;O\u0026rsquo; meaning cOllapsed. If a node has been collapsed (i.e., O $\\in$ flags_(n)), it is always treated in this safe, but field-insensitive, manner.\nAvoid Exponential Behavior Full context-sensitive cloning is susceptible to exponential behavior in theory, however, the unification approach used effectively eliminates this in two ways:\n unifications inherently merges together most of the nodes created throught the cloning process. In case of analysis failure, when the analysis must assume that many nodes must all point to each other, unification based approcaches aggressively merge these nodes, shrinking the representation (e.g. 253.perlbmk, which is largely not type-safe).  Construction Algorithm DS graphs are created and refined in a three step process.\n First, construct a DS graph for each function in the program, using only intraprocedural information (a \u0026ldquo;local\u0026rdquo; graph); Second, a \u0026ldquo;Bottom-Up\u0026rdquo; analysis phase is used to eliminate incomplete information due to callees in a function, by incorporating information from callee graphs into the caller\u0026rsquo;s graph (creating a \u0026ldquo;BU\u0026rdquo; graph). Finally, a \u0026ldquo;Top-Down\u0026rdquo; phase eliminates incomplete information due to incoming arguments by merging caller graphs into callees (creating a \u0026ldquo;TD\u0026rdquo; graph).  The BU and TD phase operate on the \u0026ldquo;known\u0026rdquo; Strongly Connected Components (SCCs) in the call graph.\nA node must not be marked complete until it is known that all callers and callees potentially affecting that node have been incorporated into the graph.\nBottom up (From 2005Embed:) The \u0026ldquo;complete bottom-up\u0026rdquo; DS graph for a function incorporates the effects of all functions reachable from the current function (i.e., immediate callees and their callees and so on), including functions called via function pointers3.\nTop down (From 2005Embed:) A final, \u0026ldquo;top-down\u0026rdquo; DS graph of a function incorporates the effects of both the callers as well as the callees of a function, so that it captures the full set of memory objects and aliasing relationships from all possible call sites (as well as those due to side effects of callee functions).\nType inference No type inference (superseded by below): (From 2005LattnerPhD) DSA extracts LLVM types for a subset of memory objects in the program. It does this by using declared types in the LLVM code as speculative type information, and checks conservatively whether memory accesses to an object are consistent with those declared types, without having to perform type-inference.\nInference based on uses:\n(From 2005-TR-SAFECODE) DSA attempts to compute type information for every \u0026ldquo;points-to set\u0026rdquo; in the program by inferring the intended type based on the uses of pointers and not based on the type declarations or cast operations in the program. The \u0026ldquo;uses\u0026rdquo; include:\n indexing operations (\u0026amp;(x-\u0026gt;Fld) and \u0026amp;E[E]) loads stores indirect calls  By ignoring casts and considering only actual uses, DSA is able to infer heap objects allocated via the malloc operation in C, which is untyped: the (usual) cast of the returned pointer value is ignored, but any uses of the pointer are correctly considered.\nExperiments: DSA can infer type information for the targets of 70% of load/store operations in most C programs (on average), and over 90% in many programs.\nConsistent Type: If all pointers to a points-to set are used consitently as one type $\\tau *$ (or as the appropriate type for a field within $\\tau$), then DSA infers the type of all objects in that set to be $\\tau$.\nInconsistent Type: If type of pointers are not consistent in the points-to set, then DSA marks the type of the object to be \u0026ldquo;Unknown\u0026rdquo;.\nImplementation Complete DSA in LLVM, and analysis is performed entirely at link-time, using stubs for standard C library functions to reflect their behavior2.\nEvaluation Benchmark: SPEC CPU 95, SPEC CPU 2000, and unbundled programs (Povray 3.1, NAMD, boxed-sim and fpgrowth).\n How fast and how much resource required?\n How much type information is DSA able to infer?\n How precise is DSA for alias analysis?\n  Memory Instructions4 as a metric for benchmark size in addition to LoC.\nmax |SCC|: the size of the largest SCC in the call graph for the program.\nType inference result The following graph shows the type inference result:\nThe first two columns, Benchmark and Mem Instrs list the name and total number of memory instructions (including address arithmetic, calls, etc)\nSafe Access: the number of load/store instructions that target non-collapsed complete nodes.\nUnsafe Access: the number of load/store instructions which target either collapsed or incomplete nodes.\nApplication Automatic Pool Allocation Pointer Compression  Sensitivities of Data Flow Analysis, wiki. ↩ Macroscopic Data Structure Analysis and Optimization. Chris Lattner Ph.D. Thesis. 2005. ↩ Automatic pool allocation: Improving performance by controlling data structure layout in the heap. PLDI, 2005. ↩ Memory instructions are load, store, malloc, alloca, and getelementptr instructions. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/prog-ana/complexity/halting/",
	"title": "Undecidability of Program Correctness",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://safersys.github.io/mm/en/cheri/intro/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": " Questions  Code pointers in Cheri is protected from being corrupted. Can it prevent the code reuse attack also? If not, how to enhance it?\n Code reuse that depends on the corruption of return address might be prevented if ret addr is \u0026lsquo;well protected\u0026rsquo;.  Sadly not. Any executable capability in the \u0026lsquo;valid\u0026rsquo; set of current process can overwrite the return address on the stack;  Code reuse that depends on the corruption of return address might be prevented if no memory error can be used to overwrite the return address.\n How to prove there is no memory error in CHERI?   Code reuse by data corruption (data oriented programming) might be prevented if data is well protected.\n How to prove there is no memory error in CHERI?    The heavy and deep motivations of CHERI: Motivations\nHistory CHERI ISA Refinement History   2016 v5: Initial in-kernel privilege limitation 2017 v6: Exception free domain transition 2019 v7: Temporal memory safety\n Initial CHERI architecture in 2012-resolve1, 2014-ISCA2;\n Compartmentalization framework in 2016-MICRO3, 2015-SP4;\n C language compilation mode where all pointers are capabilities in 2015-ASPLOS 5;\n Use of capabilities to implement a safe JNI, 2017-ASPLOS6.\n A complete userspace execution environment with CheriABI: 2019-ASPLOS7;\n  Basics Address validity vs pointer safety  Address validity associates protection properties with regions of address space, (such as a virtual page), regardless what is stored in the region.\n Pointer safety associates protection properties with object references, a higher abstraction over the raw memory regions.\n  Capabilities Capability systems are hardware, software, or distributed systems designed to implement the principle of least privilege[^11, ^12].\nCapabilities are unforgeable tokens of authority granting rights to objects in the system. They can be selectively delegated between constrained programs to enforce security policies.\nCompartmentalization Software compartmentalization, as known as privilege separation, mitigates vulnerabilities by decomposing applications into isolated components \u0026ndash; each granted only the rights it requires to operate.\nCompartmentalization granularity describes the degree of program decompositioin. Fine-grained compartmentalization improves mitigation by virtue of the principle of least privilege: attackers must exploit\nMMU\u0026rsquo;s granularity and address validation  process-granularity fault isolation, but\n \u0026ldquo;When OS kernels act on userspace, e.g., via pointers passed in to system calls, they must act on correct set of physical pages correpsonding to the process.\u0026rdquo;  conflated protection and translation: the granularity of both is one virtual page. But\n do not scale easily to handle finer-grain protection, and do not distinguish virtual addresses from arbitrary integers: while the MMU protects the structure of the virtual memory space, the references to virtual memory are unprotected.   Overview --\nCHERI Capabilities  Tags protect capabilities in registers and memory Bounds limit range of address space accessible via pointer Permissions limit operations, e.g., load, store, fetch Sealing for encapsulation: immutable, non-dereferenceable. Compressed bounds relative to 64-bit virutal address.  Protection Semantics for Pointers  Integrity and provenance validity  ensure that valid pointers are derived from other valid pointers via valid transformations; invalid pointers cannot be used  Bounds prevent pointers form being manipulated to access the wrong object; Permissions limit unintended use of pointers; e.g., W^X for pointers; Monotonicity prevents pointer privilege escalation; e.g., broadening bounds.  However, bounds and permissions must be initialized correctly by software \u0026ndash; e.g. stack allocator, heap allocator, dynamic linker\nTwo levels of abstraction (v5:) Cheri allows software privilege to be minimized at two levels of abstraction.\n architectural least privilege: memory capability.  data pointers: against data-oriented vulnerabilities, such as buffer overflows. code pointers: support CFI by preventing corruption of code pointers/return addresses.   application-level least privilege: software compartmentalization using object capabilities.  Code pointers  CHERI: A Research Platform Deconflating Hardware Virtualization and Protection. RESoLVE, 2012. ↩ The CHERI capability model: Revisiting RISC in an age of risk. ISCA, 2014. ↩ Fast Protection-Domain Crossing in the CHERI Capability-System Architecture. MICRO, 2016. ↩ CHERI: A Hybrid Capability-System Architecture for Scalable Software Compartmentalization. SP, 2015. ↩ Beyond the PDP-11: Processor support for a memory-safe C abstract machine. ASPLOS, 2015. ↩ CHERI JNI: Sinking the Java Security Model into the C. ASPLOS, 2017. ↩ CheriABI: Enforcing Valid Pointer Provenance and Minimizing Pointer Privilege in the POSIX C Run-time Environment. ASPLOS, 2019. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/sys-sec/security-pol/",
	"title": "Security Policies",
	"tags": [],
	"description": "",
	"content": "PORTIA: Of a strange nature is the suit you follow;\nYet in such rule that the Venetian law\nCannot impugn you as you do proceed.\n[To Antonio.] You stand within his danger, do you not? \u0026ndash; The Merchant of Venice, IV, i, 177\u0026ndash;180\n"
},
{
	"uri": "https://safersys.github.io/mm/en/sys-sec/security-pol/01-definition/",
	"title": "Definition of &#39;Security Policy&#39;",
	"tags": [],
	"description": "",
	"content": "Book: Computer Security, Art and Science, By Matt Bishop, 2nd edition.\n A security policy defines \u0026ldquo;secure\u0026rdquo; for a system or a set of systems.\nA security policy is a statement that partitions the states of the system into a set of authorized, or secure, states and a set of unauthorized, or nonsecure, states.\n "
},
{
	"uri": "https://safersys.github.io/mm/en/sva/safecode/2003nogc/",
	"title": "Memory Safety Without Runtime Checks or Garbage Collection",
	"tags": [],
	"description": "",
	"content": " Reference1\nChallenge: dangling pointers Proving statically that a general C program (for example) never dereferences a freed pointer (the \u0026ldquo;dangling pointer\u0026rdquo; problem) is undecidable.\nRegion-based memory management, however, has been used to guaranttee the safety of pointer-based accesses to region data without garbage collection, but with limitations: 1) manual effort to convert program to use regions; 2) many solutions disallow explicit deallocation.\nAutomatic regions inference algorithms have been developed to solve limitation completely or partially, such as in ML, or Cyclone. But these languages disallow explicit deallocation.\nIn this work, we use our fully automatic region inference algorithm called Automatic Pool Allocation that works for C with explict malloc and free. The transformation solves both the limitations above.\nUnfortunately, allowing individual object deallocation means that the transformation does not ensure memory safety.\nRestriction Rules for C  T1. Strong type: all variables, assignments and expressions (as in 2002); T2. Cast to a pointer from other types are disallowed; certaion pointer to pointer casts of two compatible targets are allowed (2002+);\n T3. Union can only contain types that can be cast to each other (as in 2002).\n  Rules for pointer safety:\n P1. Every local pointer variable must be initialized before being referenced (as in 2002); P2. Any individual type should be no larger than the size of the reserved address range (as in 2002); P3. The address of stack location cannot be stored in a heap-allocated object or a global variable, and cannot be returned from a function (new from 2002);  Heap safety by pool allocation  Memory Safety Without Runtime Checks or Garbage Collection. LCTES, 2003. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/mem-safe/temporal/",
	"title": "Temporal",
	"tags": [],
	"description": "",
	"content": " References:\n[1] CETS: Compiler-Enforced Temporal Safety for C, ISMM, 2010. [paper]\nBasics Location-based temporal checking Use location (or address) to determine whether it is allocated or not. Metadata records the allocated/deallocated status of each location.\nUpdate the metadata upon all memory allocations/deallocations. Metadtata is checked during memory access.\n Cannot detect the re-allocated dangling pointers.   Meta-data can be implemented in\n tree structure, such as splay tree. shadowspace, a large, directly accessed memory region, a hashtable, or a trie-based data structure.  Identifier-based temporal checking Associates a unique (never reused) identifier with each memory allocation.\nPer-pointer metadata via fat pointers Pointers are extended into multi-words.\n Memory layout thus is changed. Interfacing with libraries is challenging. SoftBound: disjoint pointer-based metadata shadowspace for compatibility, but no temporal.  Set-based indentifier checking\nSet data structure (such as hash table) is used to track allocation/deallocation.\n O(1) lookups. overheads on every memory reference.  Lock-and-key identifier checking\nEvery pointer is a tuple consisting of an address and a key. Every object in the heap begins with a lock. A pointer to an object in the heap is valid only if the key in the pointer matches the lock in the object.\n A new key value is created when a new heap object is created; When an object is reclaimed, its lock is changed to some arbitrary value, so that the keys in any remaining pointers will not match. Overhead: add extra words of storage for every pointer and every object in the heap; comparing the lock and key on every memory access.  "
},
{
	"uri": "https://safersys.github.io/mm/en/sva/poolalloc/",
	"title": "Automatic Pool Allocation",
	"tags": [],
	"description": "",
	"content": " Reading List:\n[1] Automatic pool allocation: Improving performance by controlling data structure layout in the heap. PLDI, 2005.\n[2] Linear Regions Are All You Need. European Symposium on Programming, 2006 paper\nRegion-based memory management Tofte-Talpin Data are allocated within lexically-scoped regions and all of the objects in a region are deallocated at the end of the region\u0026rsquo;s scope.\n restrictions on when data can be effectively reclaimed memory leaks  Cyclone\u0026rsquo;s dynamic regions and unique pointers Pool Allocation The idea of instrumentation How to determine a pool for which data structures Applicaions SAFECode Performance optimization "
},
{
	"uri": "https://safersys.github.io/mm/en/sva/",
	"title": "Secure Virtual Architecture",
	"tags": [],
	"description": "",
	"content": " Todos  Where is the pool metadata created/used in SAFECode passes? Where is the runtime check instrumentation in SAFECode passes?  Learn the code from SVA on FreeBSD and propose a solution for the policy to be ported/re-implemented on CheriBSD:\n sosp 2007\n booting signal handler dispatch code I/O instructions. kernel allocators. for analysis(ch6.3): int to pointer casts, stack usage, sys_iotctl, initial task structure, stack pointer to structure.   sec 2009\n memory mapped I/O MMU configuration context switching, thread creation  sp 2014, KCoFI\n label based protection for programmed indirect jumps; a thin run-time layer protects key OS data structures like thread stacks and monitors all low-level state manipulations performed by the OS.  asplos 2014, Virtual Ghost\n compiler instrumentation run-time checks   Top Wonderings  How can SAFECode be used to enforce compartmentalization in a single address space? How does the compartmentalization look like?\n LLM: Like automatic memory partition using pointer analysis as in DSA, can we do automatic program partition using some similar static analysis techniques?  A two-compartment address space: How can we use SAFECode to eliminate the need of transition between user/kernel mode?\n LLVA-OS: Kernel operations as language semantics instead of a lib or handwritten assembled OS?\n abstracting kernel features as special imperative operations with kernel semantics compilers taking control the entire kernel code just as how it is controling an application. But this application(the kernel) is written with a new language with kernel semantics. Instead of restrict C language, how can we extend it to support OS operations as the language\u0026rsquo;s \u0026lsquo;native\u0026rsquo; mechanisms, just as go in Golang for multi-threading?   Compared to CCured with SAFECode?\n CCured (From 2014-ISCA-CHERI1): elides bounds checks where it can statically prove them unnecessary. Not thread-safe due to non-atomic pointer access (as noted in its documentation).    Q \u0026amp; A  What is the LLVM address space?  John: better name \u0026lsquo;namespace\u0026rsquo;: one namespace for memory load/store; another namespace for IO port load/store.   Contents  Data Structure Analysis  Q \u0026amp; A How many incomplete nodes during evaluation? Ans: Not much, but most program exists. Including the collapsed nodes, ranging from 1.2% ~ 88.5%. See evaluation: type inference result Basics Flow sensitive1: takes into account the order of statements in a program. Path Sensitive: takes into account the branch conditions. Context Sensitive: names objects by entire acyclic call paths. A callee will return to its single call site instead of all possible call sites.\n Automatic Pool Allocation   Reading List: [1] Automatic pool allocation: Improving performance by controlling data structure layout in the heap. PLDI, 2005. [2] Linear Regions Are All You Need. European Symposium on Programming, 2006 paper Region-based memory management Tofte-Talpin Data are allocated within lexically-scoped regions and all of the objects in a region are deallocated at the end of the region\u0026rsquo;s scope. restrictions on when data can be effectively reclaimed memory leaks Cyclone\u0026rsquo;s dynamic regions and unique pointers Pool Allocation The idea of instrumentation How to determine a pool for which data structures Applicaions SAFECode Performance optimization  SAFECode  Questions/Todos Runtime check of SAFECode. LLM: Runtime checks in SAFECode Function Pointers in SAFECode? LLM: Function pointers are checked against a static CFG at runtime (some could be checked at compile time). Where does the pool meta-data stored and used? Can we also store meta-data for all pointers in type-unknown regions? What is affine transformations? used in Control-C Overview Memory safety in C language.\n LLVA OS  References: 2006-LLVA-OS 1 2003-LLVA 2 Idea of LLVA and LLVA-OS LLVA (Low Level Virtual Architecture) supports arbitrary languages including C, and enables sophisticated analyses and optimizations. It provides computational, memory access, and control flow operations. However, LLVA \u0026ldquo;lacks operations a kernel needs to configure hardware behavior and manipulate program state\u0026rdquo;. Thus comes LLVA-OS. LLVA-OS is a set of extensions to LLVA that provides an interface between the OS kernel and a general purpose processor architecture.\n SVA-OS  References: 2007-SOSP-SVA 1 2009-SEC-SVA 2 Memory Safety by kernel C language memory safety in kernel\u0026rsquo;s code base Memory safety related functionality of the kernel process states in trap/exceptions, including context switching. virtual/physical page mappings I/O memory, DMA memory Idea of SVA-OS LLVA-OS is an interface prvoides \u0026ldquo;richer OS-information for hardware, greater flexibility in evolving hardware, and sophisticated analysis and optimization capabilities for kernel code\u0026rdquo;. Questions/Proposals Secure Virtual Architecture: A Safe Execution Environment for Commodity Operating Systems, SOSP, 2007.\n Memory Safety in Hardware and Software Interactions  Secure HW/SW Interface Motivation OS memory safety research Memory safety for OS code: OS designs based on safe languages; Compiler techniques such as SVA-M to enforce memory safety for commodity OSs in unsafe languages; Instrumentation techniques to isolate a kernel from extensions such as device drivers; Singularity, SPIN, JX, JavaOS, SafeDrive, and SVA-M are examples of system that enforce a safe execution environment. Common asumptions of OS memory safety research Unfortunately, all these memory safety techniques (except Verve, which has very limited I/O and no MMU support) make assumptions that are routinely violated by low-level initeractions between an OS kernel and hardware, even if implemented in safe programming language.\n Virtual Ghost  Reference:  Intrinsics  Reference:   2014-ISCA-CHERI, p9. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/langs/go/tour/",
	"title": "Tour",
	"tags": [],
	"description": "",
	"content": " A Tour of Go\nTypes basic types:\nbool; // false is zero (initial) value for bool\nstring; // \u0026ldquo;\u0026rdquo; (the empty string) is zero (initial) value for string\nint, int8, int16, int32, int64\nuint, uint8, uint16, uint32, uint64, uintptr\nbyte // alias for uint8\nrune // alias for int32, Unicode point\nfloat32, float64\ncomplex64, complex128\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/cmplx\u0026#34; ) var ( ToBe bool = false MaxInt uint64 = 1\u0026lt;\u0026lt;64 - 1 z complex128 = cmplx.Sqrt(-5 + 12i) ) Type conversion: explicit only; new_type(variable_name).\nType inference: by := or var\n when the right hand side of the declaration is typed, the new variable is of that the same type:  { var i int j := i // j is an int }  when right hand side contains an untyped numeric constant, the new variable may be an int, float64, or complex128 depending on the precision of the constant.  package main import \u0026#34;fmt\u0026#34; func main() { v := 42 // int  v2 := 42.01 // float64  v3 := 9.4 + 0.3i // complex128 \tfmt.Printf(\u0026#34;v is of type %T\\n\u0026#34;, v) fmt.Printf(\u0026#34;v2 is of type %T\\n\u0026#34;, v2) fmt.Printf(\u0026#34;v3 is of type %T\\n\u0026#34;, v3) } Functions/Variables Functions/Variables: type comes after the variable name; omit redundant names; multiple returns; named return values;\nfunc add(x int, y int) int { return x + y } func swap(x, y int) (int, int) { //omit the type but the last, for consecutive shared type name. \treturn y, x // Go can return any number of result } Named return values:\nfunc split(sum int) (x, y int) { x = sum * 4 / 9 // named return values are treated variables defined at the top of a function \ty = sum - x return // a \u0026#39;naked\u0026#39; return returns named return values } func main() { fmt.Println(split(17)) // will print \u0026#39;7 10\u0026#39; }  Motivation: the confusing syntxt in C from Go\u0026rsquo;s delcaration Syntax:  { char *argv[]; // name in middle int (*fp) (int (*) (int, int), int); // function passed as parameter int (*(*fp)(int (*)(int, int), int))(int, int); // return a function }  C\u0026rsquo;s syntax is read in Spiral: Clockwise/Spiral Rule.\n Go\u0026rsquo;s syntax, read from left to right:\n  { x int // x: int p *int // p: pointer to int a [3]int // a: array [3] of int  f func(func(int,int) int, int) int //function passed as a parameter f func(func(int,int) int, int) func(int,int) int //returns a function } Variables: var and :=\nvar c, python bool var x, y int = 1, 2 // initialization var cxx, python3, java = true, false, \u0026#34;no!\u0026#34; // type can be omitted if initialization is present  func main() { var i int prolog, coq := true, \u0026#34;Yes!\u0026#34; // short variable declaration by \u0026#39;:=\u0026#39;, only used insie the function  fmt.Println(i, c, python) fmt.Println(x,y,cxx,python3,java) fmt.Println(prolog, coq) } Constants Like variables but with const and its expression for value, e.g. const Pi = 3.14\nconstant cannot use :=\nNumeric constants are high-precision values.\nPackages Packages: package main\nImports: import \u0026quot;fmt\u0026quot;\nExported names: begins with a capital letter;\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; ) import \u0026#34;math\u0026#34; func main(){ fmt.Println(\u0026#34;My favorite number is\u0026#34;, rand.Intn(1000)) fmt.Println(\u0026#34;PI:\u0026#34;, math.Pi) }  "
},
{
	"uri": "https://safersys.github.io/mm/en/sva/safecode/2005embed/",
	"title": "2005Embed",
	"tags": [],
	"description": "",
	"content": " Reference1:\nRestricted C + Compiler = Safe language benefits with no garbage collection, no runtime checks.\nSafe definition: define a software entity (module, thread, or a complete program) to be safe if:\n not out of bound: never reference a memory location outside the data area by or for the entity.\n no alien code execution: never executes instructions outside the code area created by the compiler and linker within that space.\n  Except dangling pointers, detect and prevent all other errors that could be prevented by a language with strong type safety.\nReplace null ptr runtime check with hardware address space protection.\nCompiler techniques 2 new + 2 previous\n automatic pool allocation: \u0026lsquo;safe dangling ptrs\u0026rsquo; interprocedural algorithem: propagating constraints on integer variables \u0026amp; prove the safety of affine array reference on integer variables.\n memory initialization using illegal address from hardware protection\n escape analysis: prevent dangling ptrs to stack objects.\n  Restrictions on C Complex/Unanalyzable array references are not allowed. (Or in future work, allowed with runtime checks added.)\n  Memory Safety Without Garbage Collection for Embedded Applications, ACM Transactions on Embedded Computing Systems, 2005. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/riscv/",
	"title": "RISC-V",
	"tags": [],
	"description": "",
	"content": "References:\n[1] TIMBER-V: Tag-Isolated Memory Bringing Fine-grained Enclaves to RISC-V. NDSS, 201902. paper\n[2] XuanTie 910, Pingtouge (Honey Badger), 20190725.\n Attacks  Reference1 A2: Analog Malicious Hardware Reference1 \u0026ldquo;In the open spaces of an already placed and routed design, we contruct a circuit that use capacitors to siphon charge from nearby wires as they transition between digital values.\u0026rdquo; \u0026ldquo;When the capacitors fully charge, they deploy an attack that forces a victim flip-flop to a desired value, e.g the privileged bit for the processor.\u0026rdquo; \u0026ldquo;We replace the hundreds of gates required by conventional counter-based triggers implemented using digital logic with analog components \u0026ndash; a capacitor and a few transistors wrapped-up in a single gate.\n "
},
{
	"uri": "https://safersys.github.io/mm/en/sva/safecode/steensgaard/",
	"title": "Steensgaard",
	"tags": [],
	"description": "",
	"content": " Reference: B. Steensgaard. Points-to analysis in almost linear time. POPL, 1996.1\nType system   B. Steensgaard. Points-to analysis in almost linear time. POPL, 1996. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/cheri/",
	"title": "CHERI",
	"tags": [],
	"description": "",
	"content": " Capability Hardware Enhanced RISC Instructions\nTop wonderings  CHERI itself:\n How does CHERI support multi-threading? What is the mechanism of capability revocation in CHERI? Or use-after-free, capability changes/updates to all pointers pointing to a single object, etc..  Is ring-based privilege separation removable?\n Is the process model (with context switch consequence) a must for future applications, while the 64-bit address space is large enough to hold many applications?\n If we don\u0026rsquo;t have process model, all application sharing a single address space, how does the operating system do scheduling? How to run applications on multi-cores?\n Singularity, Midori, Verve  Achieve a sound and complete pointer analysis by constraining, and/or extending the Arch, PL, and OS designs? For the purpose of formal verification of the entire software stack.\n What CHERI cannot protect?\n most tasks in kernel\u0026rsquo;s control: memory management via page tables process create, capability initialization domain transition context switches  Given the theoretical secure isolation of sandboxes in CHERI, an interesting problem would be whether a cross-domain transition to/from trampoline sandbox is more efficient than the transition to/from kernel. And, how many sandboxes a single address space can have in scale. Or how to design sandbox interaction topology to avoid the bottleneck scenario in the traditional kernel/user architecture where a kernel is the bottleneck.\n a secure \u0026lsquo;trampoline\u0026rsquo; domain for domain transition. A sandbox that mimics the kernel to maintain a trusted stack that is not visible to all other domains outside.\n a \u0026lsquo;distributed\u0026rsquo; trampoline sandbox framework for domain transition? Each time a domain invokes another domain, a new \u0026lsquo;trampoline\u0026rsquo; domain is created dynamically with its own protected stack and ensures the return address will not be corrupted.\n   Todos  CheriBSD  booting: pmap thread create, context switch   Quotes  \u0026hellip; adoption of compartmentalization has been limited by a conflation of hardware primitives for virtual addressing and separation, leading to inherent performance and programmability problems when implementing fine-grained separationi.\nSpecifically, we seek to decouple the virtualization from separation to avoid scalability problems imposed by translation look-asside buffer (TLB)-based Memory Management Units (MMUs), which impose a very high performance penalty as the number of protectino domains increases, as well as complicating the writing of compartmentalized software.\nThe CHERI ISA provides a sound and formally based architectural foundation for the principled development of highly trustworthy systems.\n Contents  Introduction  Questions Code pointers in Cheri is protected from being corrupted. Can it prevent the code reuse attack also? If not, how to enhance it? Code reuse that depends on the corruption of return address might be prevented if ret addr is \u0026lsquo;well protected\u0026rsquo;. Sadly not. Any executable capability in the \u0026lsquo;valid\u0026rsquo; set of current process can overwrite the return address on the stack; Code reuse that depends on the corruption of return address might be prevented if no memory error can be used to overwrite the return address.\n Cheri Domain  Reference: [1] Fast Protection-Domain Crossing in the CHERI Capability-System Architecture, MICRO, 2016. [2] CHERI: A Hybrid Capability-System Architecture for Scalable Software Compartmentalization, Oakland, 2015. [3] CHERI Programmer\u0026rsquo;s Guide, UCAM-CL-TR-877, 2015. Questions Globals Across Domains Globals are accessible to all domains, no distinguish. This means if some data is passed from Domain A to Domain B, an unrelated domain, say Domain C, will also have a chance to know the data.\n Cheri C Model  An implementation of C abstract machine that can run legacy C code with Strong memory protection guarantees.\n CheriABI  Todos: what is the 1% of the C userspace not adapted to CHERI? Why? Lele: idiom violations/undefined behaviors; need manual change to be adapted. How to prevent confused-deputy attacks via the kernel? How cheri generate dynamically linked programs? What is ABI\u0026rsquo;s relation with Compilers, OS, and architectures? What is ABI? Motivation/Problems Problem of C C language is not safe. memory errors; injecting, manipulating, or abusing pointers in the run-time environment; explicit: declared data/code pointers; implicit: generated code to implement global variables (PIC, GOT, PLT) or return addresses; by the runtime to implement cross-library control flow.\n Cheri Concentrate  Overview Cheri Concentrate(CC) is a compression scheme applied to CHERI. CC achieves the best published region encoding efficiency, solves important pipeline problems caused by a decompressed register file. Problem The object bounds and permission information encoded in capability pointers cause the largest overhead among all overheads. Thus need a new encoding scheme to reduce overhead, i.e a method for compression and decompression. Challenge Pipeline optimization in terms of the hardware changes for the encoding scheme.\n Cheri Kernel  References: [1] CHERI ISA v5 (2016), v6(2017), v7 (2019). [2] CheriBSD, github, link. 2016 v5: Initial in-kernel privilege limitation 2017 v6: Mature kernel privilege limitation [3] CHERI programmer\u0026rsquo;s guide, UCAM-CL-TR-877, 2015. Questions/Proposals Kernel has no capability state during context switch: kernel state How does CheriBSD do memory partition for physical memory tags? In details Kernel Capability Kernel Change List\n Cheri Userspace  Change List libprocstat(3) library and procstat(1) command: extended to inspect sandbox statistics. libcheri(3): a sandbox API, and a set of system-class objects that can be delegated to sandboxes. Currently (1), this consists of a singleton system object that provides the ability to print to stdout, and a file-descriptor class that allows delegation of individual kernel-provided file descriptors to sandboxes. libc_cheri(3): core C-language APIs and services within sandboxes.\n Hacking  Reference: Quick pinning CHERI source, good for both lib and kernel: __has_feature(capabilities), used in sys/, bin/, lib/, libexec/, contrib/, include/, stand/, and *.h, *.c; defined(__CHERI__), used in sys/, lib/, contrib/, and *.h, *.c, *.S;  Cheri Formal  References: [1] CHERI ISA v5 (2016). Existing formal methodology applied to software security has significant problems with multi-address-space security models; formal approaches have relied on the usefullness of addresses(pointers) as unique names for objects. Whereas this weakness in formal methods is a significant problem for traditional CPU designs, which offser security primarily through rings and address-space translation, CHERI\u0026rsquo;s capability model is scoped within address spaces. This offers the possibility of applying existing software proof methodology in the context of hardware isolation (and other related properties) in a manner that was previously infeasible.\n Cheri Link  archetypes learning.md\n Cheri ISA Semantic  References: [1] ISA Semantics for ARMv8-A, RISC-V, and CHERI-MIPS. POPL, 2019 Basiscs Architecture specifications define the fundamental interface between hardware and software: the envelope of allowd behaviour for processor implementations, and the basic assumtions for software development and verification. In practise, they are typically prose and pseudocode documents, not rigorous or executable artifacts, leaving software and verification on shaky ground. Sail: an ISA semantic language with dependent type system.\n "
},
{
	"uri": "https://safersys.github.io/mm/en/sys-sec/attacks/conpe/",
	"title": "Container Privilege Escalation",
	"tags": [],
	"description": "",
	"content": "Reference:\n "
},
{
	"uri": "https://safersys.github.io/mm/en/sys-sec/attacks/",
	"title": "Attacks",
	"tags": [],
	"description": "",
	"content": "Reference:\n Privilege Escalation  Reference:  Container Privilege Escalation  Reference:  DOP  Jujutsu References: [1] Control Jujutsu: On the Weaknesses of Fine-Grained Control Flow Integrity. CCS, 2015. A new attack on fine-grained CF that exploit the incompleteness of pointer analysis, when combined with common software engineering practices, to enable an attacker to execute arbitrary malicious code. Concepts: ICS: Indirect Call Site ACICS: Argument Corruptible Indirect Call Site RCE: Remote Code Execution DSA: Data Structure Analysis DEP: Data Execution Prevention ASLR: Address Space Layout Randomization SSP: Stack Smashing Protection ROP: Return-oriented Programming JOP: Jump-Oriented Programming Threat Model The threat model in this paper is a remote attacker trying to hijack control of a machine by exploiting memory vulnerabilities.\n "
},
{
	"uri": "https://safersys.github.io/mm/en/sva/safecode/typesys/",
	"title": "Type System in SAFECode",
	"tags": [],
	"description": "",
	"content": " Q \u0026amp; A  How to do encoding? What kind of information has been encoded? How does the type checking work on those encodings? What kinds of safety property can be checked?  Program Presentation SAFECode support full C, but here a subset of C is used the simplify the presentation:\nFigure 2006DinakarPhD1, same as in 2005SAFECodeTR2: This language includes most sources of potential memory errors in the weakly typed C language, including:\n P1. dangling pointers to freed heap memory; P2. array bound violation; P3. access via uninitialized pointers, and P4. arbitrary cast from an int type to another pointer type and subsequent use.  Same as in C: int, char, cast, malloc, free;\nNew from SAFECode: alloca and galloc : alloca to allocate memory on stack; galloc to allocate/initilize global variables. These two features make it unnecessary to apply the \u0026amp; operator to get the address of a stack variable or global object; \u0026amp; is only used for indexing into structures, arrays and for function pointers. $\\rightarrow$ Lele: why is this important?\nPointer Analysis From 2006DinakarPhD1/2005SAFECodeTR2:\nIntuitively, the pointer analysis representation can be thought of as a storage-shape graph, also referred to as a points-to graph. Pointers pointing to two different nodes in the graph are not aliased.\n Each node represents a set of memory objects created by the program Two distinct nodes represent disjoint sets of memory objects.  We assume there is one points-to graph per function, since this allows either context-sensitive or insensitive analyses.\nWe use a type system to encode the results of points-to analysis (i.e., the storage shape graph) as type attributes within the program, using a type system analogous to Steensgaard\u0026rsquo;s3.\n each points-to graph node is encoded as a distinct type, as $\\rho$ defined by association $(\\rho, \\tau)$ below; each pointer in this type system has a node attribute, $\\rho$, describing the node it points to.  For example, in Figure 3 below:\nThe type of y is int*r2, denoting that it points to objects of node (or type) r2 in the points-to graph. Since a pointer can point into objects at an offset, we use $\\tau * (p, n)$ to denote the type of a pointer pointing to offset n (where n is a compile type constant), within a struct of type $\\tau$ at node $\\rho$.\nThe statement associate($\\rho,\\tau$) associates node $\\rho$ of the graph with type $\\tau$, denoting that the node $\\rho$ contains objects of type $\\tau$. These objects may be pointers, such as associate(r1, $\\tau'$ * r2): this encodes a \u0026lsquo;points-to\u0026rsquo; edge from node r1 to node r2. associate (r1, r2) also encode the edge between r1, r2. Redundant cases like this is kept to take pointer analysis results directly from Steensgaard\u0026rsquo;s like type system3.\nAs a unification-based analysis, there can be only one target node for each variable or field of pointer type.\nMemory that is used in a type inconsistent manner, e.g., via unions or casts in C, is assigned type Unknown, which is intepreted as an array of chars.\n SAFECode: A Platform for Developing Reliable Software in Unsafe Languages, Ph.D. Thesis, 2006. ↩ Enforcing Alias Analysis for Weakly Typed Languages, TR, 2005. ↩ B. Steensgaard. Points-to analysis in almost linear time. POPL, 1996. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/mem-safe/cets/",
	"title": "CETS: Compiler Enforced Temporal Safety for C",
	"tags": [],
	"description": "",
	"content": "Overhead 1:\n48% for temporal check;\n116% for both spatial and temporal check.\n CETS: Compiler-Enforced Temporal Safety for C, ISMM, 2010. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/sva/safecode/",
	"title": "SAFECode",
	"tags": [],
	"description": "",
	"content": " Questions/Todos  Runtime check of SAFECode.\n LLM: Runtime checks in SAFECode  Function Pointers in SAFECode?\n LLM: Function pointers are checked against a static CFG at runtime (some could be checked at compile time).  Where does the pool meta-data stored and used?\n Can we also store meta-data for all pointers in type-unknown regions?\n What is affine transformations? used in Control-C\n  Overview Memory safety in C language.\nInput:\n a program written in C; The result of a flow-insensitive, field-sensitive, unification-based pointer analysis on that program.  Includes both points-to information and type information for some subset of memory objects. The analysis may use various forms of context-sensitivity.  A call graph computed for the program.  Type inference in DSA: (2005TR1:) DSA attemps to compute type information for every \u0026ldquo;points-to set\u0026rdquo; in the program by inferring the intended type based on the uses of pointers to a points-to set object, and not based on the type declarations or cast operations in the program.\nInsights (From 2006DinakarPhD) Automatic pool allocation partitions the heap into regions based on a points-to graph. This leads us to the following new insight that is the key to the SAFECode work:\n Insight1: pool based check instead of acrossing all memory range2:\n Precondition (guarantteed by DSA): unaliasable memory objects are not allocated within the same region.\n poolcheck($ph$, A, $o$): verifies that address, A, is contained within the set of memory ranges assigned to pool, $ph$, and has the correct alignment for the pool\u0026rsquo;s data type (or for the field at offset $o$ if $o\\neq0$)\n  Insight2: No run-time check needed on initialized pointers in TK; Runtime check needed for arithmetic derived pointers and TU pointers3.\n An initialized pointer obtained from a TK region will always be valid4; It cannot have been corrupted in an unpredictable way, e.g., via arbitrary casts and subsequent stores (it would then be in a TU region).  Insight3: Reused TK region will not violate type safety5.\n Insight4: Release is safe only when no pointers into that regions6.\n  Official Document  SAFECode Software Architecture Manual Installation User Guide  Published Papers:\nControl-C in 2002CASES 7, 2003 LCTES 8, 2005Embed 9, 2005SAFECodeTR 1, 2005PLDIPool10,\n2006ICSE 11, 2006PLDI 12, 2006DinakarPhD 13, 2011Formal 14.\nImplementation The SAFECode analysis and transformation sources are organized as follows (from manual 15):\n lib/ArrayBoundChecks: This library contains several analysis passes for static array bounds checking. lib/InsertPoolChecks: This library contains the transform passes for inserting run-time checks and for inserting code to register memory objects within individual pools. It also contains the CompleteChecks pass which implements the Check Completion Phase. lib/OptimizeChecks: This library contains several passes for optimizing run-time checks. lib/RewriteOOB: This library contains passes for implementing Ruwase/Lam pointer rewriting. This code allows SAFECode to tolerate out-of-bounds pointers that are never dereferenced. lib/DebugInstrumentation: This library implements code that modifies run-time checks to contain additional debug information (if such debug information is present in the program). It is used in SAFECode’s debug tool mode. lib/DanglingPointers: This library contains a pass that modifies a pro- gram to perform dangling pointer detection.  \nIn details  Control-C  Control-C (in 2002 CASES1) , a subset of C, but with key restrictions designed to ensure that memory safety of code can be verified entirely by static checking, under certain system assumptions. Restrictions on C T1. Requires strong typing of all functions, variables, assignments, and expressions, using the same types as in C. T2. Disallows casts to or from any pointer type. Casts between other types (e.g., intergers, floating point numbers, and characters) are allowed.\n Memory Safety Without Runtime Checks or Garbage Collection  Reference1 Challenge: dangling pointers Proving statically that a general C program (for example) never dereferences a freed pointer (the \u0026ldquo;dangling pointer\u0026rdquo; problem) is undecidable. Region-based memory management, however, has been used to guaranttee the safety of pointer-based accesses to region data without garbage collection, but with limitations: 1) manual effort to convert program to use regions; 2) many solutions disallow explicit deallocation. Automatic regions inference algorithms have been developed to solve limitation completely or partially, such as in ML, or Cyclone.\n 2005Embed  Reference1: Restricted C + Compiler = Safe language benefits with no garbage collection, no runtime checks. Safe definition: define a software entity (module, thread, or a complete program) to be safe if: not out of bound: never reference a memory location outside the data area by or for the entity. no alien code execution: never executes instructions outside the code area created by the compiler and linker within that space.\n Steensgaard   Reference: B. Steensgaard. Points-to analysis in almost linear time. POPL, 1996.1 Type system B. Steensgaard. Points-to analysis in almost linear time. POPL, 1996. ↩  Type System in SAFECode  Q \u0026amp; A How to do encoding? What kind of information has been encoded? How does the type checking work on those encodings? What kinds of safety property can be checked? Program Presentation SAFECode support full C, but here a subset of C is used the simplify the presentation: Figure 2006DinakarPhD1, same as in 2005SAFECodeTR2: This language includes most sources of potential memory errors in the weakly typed C language, including:\n Runtime Checks  Runtime Check in SAFECode All pointers in Type-Unknown pools are checked. All casts from int to pointer are runtime checked to ensure in the right pool. Pointers in TU are all loaded as int1 All pointers derived from array indexing operations need run-time check (2006 PLDI1), regardless of TK or TU. More about array bound checking. All function pointers need runtime check before being used. (2005-SAFECode-TR: function pointer)\n Passes  Stack Check Reference1 safecode/include/StackSafety.h: This file defines checks for stack safety. struct checkStackSafety : public ModulePass { public : ... virtual bool runOnModule(Module \u0026amp;M); virtual void getAnalysisUsage(AnalysisUsage \u0026amp;AU) const { AU.addRequired\u0026lt;DataLayout\u0026gt;(); AU.addRequired\u0026lt;EQTDDataStructures\u0026gt;(); AU.setPreservesAll(); } private : // // Tracks the DSNodes that have already been analyzed by an invocation of // markReachableAllocas(). // std::set\u0026lt;DSNode *\u0026gt; reachableAllocaNodes; bool markReachableAllocas(DSNode *DSN, bool start=false); bool markReachableAllocasInt(DSNode *DSN, bool start=false); }; } } safecode/lib/StackSafety/CheckStackPointer.\n \n Enforcing Alias Analysis for Weakly Typed Languages, TR, 2005. ↩ Original text from 2006DinakarPhD: if memory objects corresponding to each node are located in a region of the heap, we would check efficiently at run-time that a pointer is a valid member of the compile-time points-to set for that pointer, i.e., that alias analysis is not invalidated. ↩ Original text from 2006DinakarPhD: Any initialized pointer read from an object in a TK region or from an allocation site, will hold a valid address for its target region; All other pointers, i.e., pointers derived from indexing operations, and pointers from TU regions (including function pointers), need run-time checks before being used. ↩ Precondition: In the absence of dangling pointer errors and array indexing errors ↩ From 2006 DinakarPhD: In a TK (type-homogeneous) region, if a memory block holding one or more objects were freed and then reallocated to another request in the same region with the same alignment, then dereferencing dangling pointers to the previous freed object cannot cause either a type violation or an aliasing violation. ↩ From 2006 DinakarPhD: \u0026ldquo;We can safely release the memory of a region when there are no reachable pointers into that region. This gives us a way to release memory to the system. Since Automatic Pool Allocation already binds the life times of regions (using escape analysis), we can arrange for memory to be released at the end of a region’s life time.\u0026rdquo; ↩ Ensuring Code Safety Without Runtime Checks for Real-Time Control Systems. CASES, 2002. ↩ Memory Safety Without Runtime Checks or Garbage Collection. LCTES, 2003. ↩ Memory Safety Without Garbage Collection for Embedded Applications, ACM Transactions on Embedded Computing Systems, 2005. ↩ Automatic pool allocation: Improving performance by controlling data structure layout in the heap. PLDI, 2005. ↩ Backwards-Compatible Array Bounds Checking for C with Very Low Overhead, ICSE, 2006. ↩ SAFECode: Enforcing Alias Analysis for Weakly Typed Languages, PLDI, 2006. ↩ SAFECode: A Platform for Developing Reliable Software in Unsafe Languages, Ph.D. Thesis, 2006. ↩ Formalizing the SAFECode Type System, 2011. ↩ SAFECode Software Architecture Manual ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/prog-ana/pointer/",
	"title": "Pointer Analysis",
	"tags": [],
	"description": "",
	"content": " References:\n[] Pointer Analysis: Haven\u0026rsquo;t we solved this problem yet? PASTE, 2001.\nQuestions/Proposals A least restricted language that allows sound and complete point-to analysis.\n How to handle recursive data structures?  "
},
{
	"uri": "https://safersys.github.io/mm/en/mem-safe/lowfat/",
	"title": "Low Fat Pointers",
	"tags": [],
	"description": "",
	"content": "References:\n[1] Low-Fat Pointers: Compact Encoding and Efficient Gate-Level Implementation of Fat Pointers for Spatial Safety and Capability-based Security. [paper]\nLow-fat Capability Format  "
},
{
	"uri": "https://safersys.github.io/mm/en/cheri/cheri-domain/",
	"title": "Cheri Domain",
	"tags": [],
	"description": "",
	"content": " Reference:\n[1] Fast Protection-Domain Crossing in the CHERI Capability-System Architecture, MICRO, 2016.\n[2] CHERI: A Hybrid Capability-System Architecture for Scalable Software Compartmentalization, Oakland, 2015.\n[3] CHERI Programmer\u0026rsquo;s Guide, UCAM-CL-TR-877, 2015.\nQuestions  Globals Across Domains\n Globals are accessible to all domains, no distinguish. This means if some data is passed from Domain A to Domain B, an unrelated domain, say Domain C, will also have a chance to know the data.  Untagged Data Across Domains\n The untagged data in the argument list is not checked when do a CCall. Is it possible to leak information?  Performance Problem\n Memory footprints caused by larger size of pointers in pointer intensive applications: 46% on average for Olden microbenchmark.  How to selectively use capabilities and traditional pointers?  CCall/CReturn overhead.  Pure-hardware solution, but still with flexibility for OS settings? Like MMU as hardware acceleration for page tables?    Overview Sealing Capabilities are sealed using CSeal instruction, which accepts two capability-register operands:\n the code or data memory capability to be sealed, and a second capability with the Permit_Seal permission set.  The virtual address of a capability with Permit_Seal set is treated as a type. Object types prevent instance data from being used with the wrong class.\nObject-capability invocation  CCall/CReturn rely on software exception handlers to partially implement both instructions. CCall performs  Hardware checks, sealing, suitable permissions, matching types select exception vector according to results  CReturn  Trigger a software exception without checks May be eschewed if CCall is used as an asynchronous message-send primitive.  Exception handers:  flush sensitive registers before transition CHERICCallVector -\u0026gt; CHERICCall || CHERICReturn   Capability Flow Control Addressing the temporal issues when memory is passed between protection domains.\n 2-bit capability: Global vs Local cap;\n Global may be stored via any writable capability;\n Local may be stored only via capabilities that themselves have the Permit_Store_Local permission set.\n CHERIBSD: heap references as global; stack references as local. Sharing of stack data between protection domains is prevented.\n  Microarchitecture Changes  minor additions to implement compartmentalization-focused ISA extension, sealing mechanism, and capability flow control. CClearRegs: modification to register forwarding logic. zero mask on register file: a single bit for each register indicates whether a read should return zero.  Compiler Changes Modified 8KLoC in 2MLoC of total LLVM/Clang code, including LLVM C front end, MIPS backend, and target-independent optimizers.\n Capabilities are used wherever possible to limit accidental buffer overruns, protect pointers (including those used in control flow.) A new calling convention, CHERI_CCall, for functions that can be invoked across domains.  with knowledge of the function type, only the compiler is aware of which argument and return-value registers are used. Compiler clears unused argument registers in the caller context, and unusded return registers in the callee context. CCall and CReturn are responsible for clearing other registers.    OS changes Added 4KLoC in 13MLoC kernel code. More details: kernel changes\n Per-thread trusted stack that links a chain of disjoint, pre-compartment stacks used by each object executing in the thread. Each invoation, CCall saves a code and data capability that CReturn will use to resume. The caller is responsible for setting the invoked data capability ($idc) to a memory region (typically on the caller\u0026rsquo;s stack) that contains everything needed to restore state.  (2015, programmer\u0026rsquo;s guide:) Kernel implements CCall and CReturn via a combined exception handler: CHERICCallVector -\u0026gt; CHERICCall or CHERICReturn. The handlers performs tests and following ABI specifications. (from ABI: invoked code capability is in C1, data cap in C2).\nCCall will push IDC, PCC, and PC+4; CReturn pops them. PC will be in PCC in the future (2015, programmer\u0026rsquo;s guide).\nISA CCall  Checks the provided sealed code ($scc) and data (`$sdc) capabilities are valide and properly sealed, and have matching types and suitable permissions; Checks that argument capabilities are either untagged or have the Global permission. (Untagged data and globals are not protected across domains. Then, how to constrain a Global to only accessible by limited number of domains? domains ontop of domains? layers?).  ISA CReturn  Validating that any returned capability is global or NULL; Clearning non-return registers; Poping and restoring $pcc and $idc.  Performance Memory Footprints  A worst-case analysis for linked-list and tree traversal operation. Olden microbenchmark suite. Use Capabilities for all pointers. 46% overhead on average in Olden microbenchmark suite.  Domain Crossing Overhead Total cycle count, spanning userspace and kernel, for a zero-byte memcpy in a sandbox   A best-case invoke and return analysis: CCalling a zero-byte memcpy. With hardware argument validation, i.e., object type checking in CCall: -44 cycles(5.5%). With CClearRegs instruction: -172 cycles(21%).  zlib Compartmentalization Compression time for gzip with library compartmentalization   Comparison: CHERI + Process-based Compartmentatlization (Capsicum) + unmodified version. CHERI: a small, near constant, overhead.\n domain switch once. shares memory using capabilities.   Capsicum: linear overhead.\n Must transfer data using IPC.   More details    \n Hello Example CCall Examples CCall Implimentation OpenSSH Compartmentalization "
},
{
	"uri": "https://safersys.github.io/mm/en/mem-safe/",
	"title": "Memory Safety",
	"tags": [],
	"description": "",
	"content": " Quotes:\n Intel Memory Protection Extensions(MPX) and Software Guard Extensions (SGX), as well as Oracle Silicon Secured Memory (SSM), signal an unprecedented industrial willingness to implement hardware mechanisms for memory safety and security.\n Capability Pointers vs. address-space separation\n Capability pointers are stronger than fault detection schemes such as MPX and SSM, and are able to achieve provable containment at the granularity of program-defined objects that is as strong as address-space separation.\n Contents  Embed  Reference: Usfi uSFI1. Ultra-lightweight software fault isolation for iot-class devices. DATE, 2018. ↩ Minion Reference: nesCheck nesCheck1. Statically find all provable memory bugs and report them as errors; Statically find all potentially unsafe memory accesses, determine and exclude those that will never result in a memory corruption in a conservative way; report the remaining vulnerabilities as warnings; Dynamically instrument all remaining vulnerable location with runtime checks, and catch all memory errors at runtime.\n Google Native Client Sandboxing  Reference: NaCl1, PNaCl2 Original NaCl Inner sandbox, the NaCl module: code section is read-only and statically linked; code section is conceptually divided into fixed sized bundles of 32 bytes. All valid instructions are reachable by a dissassembly starting at a bundle beginning. All indirect control flow instructions are replaced by a multiple-instruction sequence (pseudo-instruction) that ensures target address alignment to a bundle boundary. No instructions or pseudo-instrucitons in the binary crosses a bundle boundary.\n Runtime Bound Checking  Reference1 Runtime Bounds Checking Reference: Runtime Defenses agains Memory Corruption, or here Three kinds of solutions: Modified pointer representation. Pointer keeps information about its referent object Incompatible with external code, libraries, etc. Special table maps pointers to referent objects Check referent object on every dereference What if a pointer is modified by external code? Keep track of address range of each object For every pointer arithmetic operation, check that the results points to the same referent object.\n Temporal  References: [1] CETS: Compiler-Enforced Temporal Safety for C, ISMM, 2010. [paper] Basics Location-based temporal checking Use location (or address) to determine whether it is allocated or not. Metadata records the allocated/deallocated status of each location. Update the metadata upon all memory allocations/deallocations. Metadtata is checked during memory access. Cannot detect the re-allocated dangling pointers. Meta-data can be implemented in tree structure, such as splay tree. shadowspace, a large, directly accessed memory region, a hashtable, or a trie-based data structure.\n CETS: Compiler Enforced Temporal Safety for C  Overhead 1: 48% for temporal check; 116% for both spatial and temporal check. CETS: Compiler-Enforced Temporal Safety for C, ISMM, 2010. ↩  Low Fat Pointers  References: [1] Low-Fat Pointers: Compact Encoding and Efficient Gate-Level Implementation of Fat Pointers for Spatial Safety and Capability-based Security. [paper] Low-fat Capability Format  SoftBound  Reference: SoftBound: Highly Compatible and Complete Spatial Memory Safety for C. PLDI, 2009. Implementation Instrumentaton: The SoftBound pass inserts code to:1 Create a base and bound value for each pointer non-memory value in the program; perform base/bound metadata manipulation prior to every memory operation that reads or writes a pointer; perform a bound check before memory operation; rewrite all function calls to pass the base and bounds. Redundant elimination:\n HardBound  References: [1] HardBound: Architectural Support for Spatial Safety of the C Programming Language. [paper] Overhead Hardbound:\n M-Mmachine  References: [1] Hardware support for fast capability based addressing. SIGPLAN, 1994. [2] CHERI Concentrate: Practical Compressed Capabilities, IEEE Transactions on Computers, 2019. M-Machine Capability Format  Intel MPX  Reference1 referee ↩  Intel MPK  References: [1] ERIM: Secure, Efficient In-process Isolation with Memory Protection Keys (MPK), SEC, 201908. paper\n SSM  Reference1 referee ↩  SGX  Reference1 referee ↩  RIPE: Runtime Intrusion Prevention Evaluator  850 buffer overflow attack forms. RIPE 1 extends 2003 NDSS 2 paper from 20 attack forms to 850 attack forms. Dimensions Location of the buffer in memory, target code pointer, overflow technique, D1: Location Stack Heap BSS segment Data segment D2: Target Code Pointer Return address Old base pointer: The previous contents of the EBP register, which is used to reference functin arguments and local variables Functino pointers: Generic function pointers allowing programmers to dymanically call different functions from the same code Longjmp buffers: Setjmp/longjmp is a technique which allows programmers to easily jump back to a predefined point in their code.\n "
},
{
	"uri": "https://safersys.github.io/mm/en/sys-sec/attacks/data-op/",
	"title": "DOP",
	"tags": [],
	"description": "",
	"content": "  Jujutsu  References: [1] Control Jujutsu: On the Weaknesses of Fine-Grained Control Flow Integrity. CCS, 2015. A new attack on fine-grained CF that exploit the incompleteness of pointer analysis, when combined with common software engineering practices, to enable an attacker to execute arbitrary malicious code. Concepts: ICS: Indirect Call Site ACICS: Argument Corruptible Indirect Call Site RCE: Remote Code Execution DSA: Data Structure Analysis DEP: Data Execution Prevention ASLR: Address Space Layout Randomization SSP: Stack Smashing Protection ROP: Return-oriented Programming JOP: Jump-Oriented Programming Threat Model The threat model in this paper is a remote attacker trying to hijack control of a machine by exploiting memory vulnerabilities.\n "
},
{
	"uri": "https://safersys.github.io/mm/en/mem-safe/softbound/",
	"title": "SoftBound",
	"tags": [],
	"description": "",
	"content": " Reference: SoftBound: Highly Compatible and Complete Spatial Memory Safety for C. PLDI, 2009.\nImplementation Instrumentaton:\nThe SoftBound pass inserts code to:1\n Create a base and bound value for each pointer non-memory value in the program; perform base/bound metadata manipulation prior to every memory operation that reads or writes a pointer; perform a bound check before memory operation; rewrite all function calls to pass the base and bounds.  Redundant elimination:\nTo eliminate some obviously redundant checks of the same pointer, our prototype performs a simple intra-procedural dominator-based redundant check elimination. These transformations are all strictly local (intra-procedural) transformations, without any whole program type inference or alias analysis.\nCalls to external functions (i.e. any library function that has not been SoftBound transformed) are mapped to wrapper functions.\nSoftBound uses standard C functions to implement the code to access the base/bound metadata and to perform the bounds checks. The SoftBound pass invokes these routines by inserting appropriate function calls that are later forcibly inlined by subsequent LLVM passes.\nEvaluation Overhead:\n67% full checking;\n22% store-only checking.\nCompiler: LLVM 2.4\nBenchmark:\n a testbed for buffer overflow attacks RIPE; real programs with spatial errors: go, compress, gzip, polymorph. SPECint, SPECfp, Olden.  Comparison:\n Valgrind/memcheck, Valgrind/ptrcheck; GCC Mudflap; Jones and Kelly version of GCC; CCured MSCC  In general, better than MSCC, worse than CCured.\nNot Complete for pointer protection:  memcpy(): infer whether the memory has pointers by looking at the type being copied at the call site \u0026ndash; not foolproof;\n functin pointers: base=bound=pointer, zero-sized object. can prevent data pointer to function pointer casting; but cannot prevent func to func casting;\n no temporal.\n   SoftBound: Highly Compatible and Complete Spatial Memory Safety for C. PLDI, 2009. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/sys-sec/defences/",
	"title": "Defences",
	"tags": [],
	"description": "",
	"content": "Reference:\n Tamper Resistant Software Design and Implementation: IVK  Paper1: Make software immune to observation and modification. Tamper-resistance using Integrity Verification Kernels: segments of code which are self-modifying, self-decrypting and installation unique. code segments communicates with other such code, creating an interlocking trust model. Threats: breach communication access controls to attack the system; computer virus; attacker as insider: may modify at will. Tamper Resistant Software Design and Implementation. 1999. ↩  Info Flow Integrity  Reference:  "
},
{
	"uri": "https://safersys.github.io/mm/en/sva/safecode/runtimechecks/",
	"title": "Runtime Checks",
	"tags": [],
	"description": "",
	"content": " Runtime Check in SAFECode  All pointers in Type-Unknown pools are checked.\n All casts from int to pointer are runtime checked to ensure in the right pool. Pointers in TU are all loaded as int1  All pointers derived from array indexing operations need run-time check (2006 PLDI1), regardless of TK or TU. More about array bound checking.\n All function pointers need runtime check before being used. (2005-SAFECode-TR: function pointer)\n  Runtime check methods:\n poolcheck(ph, A, o): verifies that the address, A, is contained within the set of memory ranges assigned to pool, ph, and has the correct alignment for the pool\u0026rsquo;s data type (or for the field at offset o, if o $\\neq$ 0).  SAFECode summary in SVA SOSP 20072:\n Prevents uninitialized reference: data flow analysis for local variables \u0026amp; initilize allocated memory to illegal address for all other pointer variables.\n Prevents array bound violations: extension of the Jones-Kelly approach for detecting array bounds violations. Uses a separate run-time search tree (a splay tree) in each pool to record all array objects at run-time, and looks up pointer values in this table to check for bounds violations.\n Ensures type-safety in TK pools.\n Ensures CFI by generating native code itself \u0026amp; preventing write to code pages \u0026amp; using runtime checks to ensure that indirect function calls match the CFG at compile time.\n Guaranttee the soundness of the operational semantics, given the correctness of analysis information (i.e., the call graph, point-to graph, and type information for TH partitions)\n   Function Ptrs  Reference: Enforcing Alias Analysis for Weakly Typed Languages, TR, 2005. Runtime Check on Function Pointers (From 2005 TR1) The call graph is simply checked explicity at each indirect call site ( some could be removed). Call graph is one of the input of SAFECode. The call graph is represented in the input type system by adding a function set attribute called $fs$ in Figure 2 to each function pointer type, making explicit the set of possible targets for that function pointer.\n Arraychecks  Reference1 Extension to JK and JKRL. Summary of Jones-Kelly from 2006ICSE1: Jones-Kelly inserts the following checks (ignoring any later optimizaiton) on each arithmetic operation involving a pointer value: JK1. check the source pointer is not the invalid value (-2); JK2. find referent object for the source pointer value using the table; JK3. check that the result pointer value is within the bounds of this referent object plus the extra byte.\n  SAFECode: Enforcing Alias Analysis for Weakly Typed Languages, PLDI, 2006. ↩ SVA. SOSP 2007. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/mem-safe/hardbound/",
	"title": "HardBound",
	"tags": [],
	"description": "",
	"content": " References:\n[1] HardBound: Architectural Support for Spatial Safety of the C Programming Language. [paper]\nOverhead Hardbound:\n"
},
{
	"uri": "https://safersys.github.io/mm/en/sva/llvaos/",
	"title": "LLVA OS",
	"tags": [],
	"description": "",
	"content": " References:\n2006-LLVA-OS 1\n2003-LLVA 2\nIdea of LLVA and LLVA-OS LLVA (Low Level Virtual Architecture) supports arbitrary languages including C, and enables sophisticated analyses and optimizations. It provides computational, memory access, and control flow operations.\nHowever, LLVA \u0026ldquo;lacks operations a kernel needs to configure hardware behavior and manipulate program state\u0026rdquo;. Thus comes LLVA-OS.\nLLVA-OS is a set of extensions to LLVA that provides an interface between the OS kernel and a general purpose processor architecture.\nTwo similar set of abstraction layers:\n Application -\u0026gt; libc -\u0026gt; operating system/hardware\n OS Kernel -\u0026gt; LLVA-OS -\u0026gt; hardware\n  OS-hardware Interfaces  Two types:\n access specialized and privileged hardware components.\n registering interrupt handlers; configuring the MMU; performing I/O.  manipulate the state of itself and other programs.\n context switching; signal delivery; process createion.    Program states virtual states  Virtual state is the system state as seen by external software, including the OS. The virtual state of an LLVA program includes:\n The set of all virtual registers for all currently active function activations (?). The implicit program counter indicating which virtual instruction to execute next. The contents of memory used by the current program. The current stack pointer indicating the bottom of the currently active stack. The current privilege mode of the processor (either privileged or unprivileged). A set of MMU control registers. A local interrupt enable/disable flag.   native states  Native state is the state of the underlying physical processor and includes any processor state used by a translated program, such as\n general purpose, floating point, and control flow registers. coprocessors, such as MMUs, FPUs.   Overhead caused by the abstraction  Our evaluation revealed where our design choices added virtualization overhead to the Linux kernel: context switching, data copies between user and kernel memory, read page faults, and signal handler dispatch.\n Applications of LLVA-OS Memory safety for kernel SVA-OS.\nKernel portability improvement If LLVA-OS is able to support a large amount of architectures. Then the same kernel code would be able to run all the architectures without any modification.\nJust like an unmodified java application runs on JVM on any architecture that could run JVM, an unmodified operating system will run on LLVA-OS on any architecture that are supported by LLVA-OS.\n? Any related work. No. Here we see that advancement gap between application research and os research.\nOS compatability of LLVA-OS Different kernels would be able to be supported by the LLVA-OS interfaces.\nJust like C, Java, and Rust can all be compiled to LLVM IR, and do optimization or security analysis in LLVM IR level, different OS kernels should also be able to be \u0026lsquo;compiled\u0026rsquo; to the LLVA with LLVA-OS, enabling \u0026lsquo;IR level\u0026rsquo; compiler analysis.\n? Any related work. No. What is the core challenge here?\nA compiler with full kernel knowledge, just like considering a kernel as a new language but contains the special instructions buried anywhere in any forms. How to compile this much messed language?\n A virtual instruction set interface for operating system kernels, WIOSCA, 2006. ↩ LLVA: A Low-level Virtual Instruction Set Architecture. MICRO, 2003. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/cheri/cheri-c-model/",
	"title": "Cheri C Model",
	"tags": [],
	"description": "An implementation of C abstract machine that can run legacy C code with Strong memory protection guarantees.",
	"content": " An implementation of C abstract machine that can run legacy C code with Strong memory protection guarantees.\nReferences:\n[1] Beyond the PDP-11: Architectural support for a memory-safe C abstract machine. 2015, ASPLOS. paper, slides\n[2] ISO/IEC 9899:2011 Information technology \u0026ndash; Programming languages \u0026ndash; C. link\n[3] Is address space 1 reserved? LLVMdev, 2015. link\n[4] CheriABI: Enforcing Valide Pointer Provenance and Minimizinig Pointer Privilege in the POSIX C Run-time Environment, ASPLOS, 2019.\nQuestion/Proposals the #pragma Pure-capability enabled for zlib, but still need the pragma changes to keep compatable with MIPS ABI.\n What does the pragma do? What will happen if we enable pure-capability for the kernel? will we also need a pragma, or we will eliminate all the pragma?  Refine Compilers instead of CHERI ISA  Instead of refine CHERI ISA to support the idioms, is it possible to change the Compiler to converting those unsafe idioms into a safe one in the older CHERI ISA?  Refine C abstract machine  How could we extend C abstract machine to include more memory safety related semantics, such as malloc, kernel\u0026rsquo;s context switching, signal handler dispatching, I/O memory, MMU, etc. Can SVA be viewed as an extended C abstract machine? But implements all extensions as a library rather than C language semantics?  Compiler assisted Temporal Safty in CHERI?  Tracking all the pointer-\u0026gt;integer-\u0026gt;pointer flows. Make the collector accurate first. Then find a way to optimize it.\n might track the integer with one more bit, indicating whether it is converted from pointers or not. allow pointer to integer, but once casted to/from a pointer, the integer automatically becomes a capability and will never be casted back again (in architecture\u0026rsquo;s view, not in user\u0026rsquo;s view).  Use SAFECode Strategy for a quoted safe.\n  Common Pointer Idioms  Around 2M lines of C code surveyed Thousands of instances found Breaking them is not acceptable  CHERI := Fat Pointers ++ Original Fat Pointers:\n Describe a pointer Add metadata   Capabilities:\n Unforgeable Monotonic length and permissions Grant rights  Original C Abstract Machine malloc() is outside of the abstract machine.  Integer arithmetic and then cast to pointers, mostly in malloc(). The C specification indicates that each block of memory returned by malloc() is an object. And it is undefined behavior to use it after calling free(). The memory that has not been returned by malloc() is not yet part of the C abstract machine. The compiler makes sufficient allowances to permit these functions to be implemented in C atop some more primitive functionality, mmap() or brk(), which deals with pages of memory.  Address translation (MMUs) is outside of the C abstract machine  memory in CHERI terminology always mean virtual memory.  Unions to subvert the type system  If the member used to read the contents of a union object is not the same as the member last used to store a value in the object, the appropriate part of the object representation of the value is reinterpreted as an object representation in the new type\u0026hellip; This might be a trap representation.\n This requirement is useful for low-level contexts: it is possbile to subvert the type system and interpret memory as differnet formats.\nCode pointers as data  C is intended to be usable on microcontrollers with separate address spaces for code and data. POSIX breaks this separation by introducing void *dlsym(...) function, used to look up a symbol in a shared library. Notion of shared libraries is beyond the scope of the C language specification. Unfortunately, looking up function pointers is a common use for dlsym, and is not defined behaviour in C.  Const in C type system is not strict  memchr in C specification, takes a const-qualified pointer as the first argument, and returns a non-const pointer derived from it.  Provenance of pointers in C is broken  pointer -\u0026gt; integer -\u0026gt; pointer. e.g. xor linked list: each node has a pointer that is the address of the previous node xor\u0026rsquo;d with the address of the next node, allowing traversal in both directions.\n unused bits in a pointer used to store information.\n  Temporal safety in C is difficult  Casting integer to pointer makes accurate garbage collection impossible. Because any integer value may potentially be combined with others to form a valid address. It is not possible to implement a copying or relocating garbage collector if it is possible for object addresses to escape from the collector.\n Efficient implementation of full temporal safety will have unexpected behavior for much existing code.\n  CHERI Refined Refine CHERI to meet C Abstract model.\nExamples:\n v1 -\u0026gt; v2 : prevent integer loaded into capability registers -\u0026gt; allow propagation of tags.\n memcpy() does not need to aware the existence of pointers in the copied data. unions too.  v2 -\u0026gt; v3: add \u0026lsquo;fat pointers\u0026rsquo; style, an offset.\n supporting arbitrary pointer arithmetic and comparison: CPrtCmp\n allow more permission fields\n additional hw checks, such as GC, info-flow tracking, integrity in concurrency, etc.\n const by removing the store permission. __input and __output to discard permissions.\n   CToPtr and CFromPtr\n will lose bound in traditional pointers. must be used carefully only in hybrid environment  __capability qualifier for hybrid compilation mode.\n v3 supports storing data in unused bit of a pointer (must in bound)\n  More refinement ongoing:  Function Pointers as Capability\n v3 can support (but not yet) using a code capability for every function: CJALR(capability jump and link register), such that when a function is executing, it is impossible to jump out of it without an explicit call. legacy compilers and linkers place constants close to the functions and depend on the program counter address to locate globals. Thus use function pointers as capabilities would break these applications.  A relocating generational garbage collector.\n use tagged memory to distinguish capbilities and other data. already implemented, but need to determine how much software will be broken on it.   Evaluation Idioms Support Summary of idioms supported by different interpretations of C abstract machine   x86/PDP-11/MIPS baselines, HardBound, Intel MPX, CHERIv2: no offset, a pointer addition decreases the range. CHERIv3: with offset, etc. a translator from C code into a simple abstract machine interpreter, to quickly modify the abstract machine and run the test cases extracted from the idioms to see which fail.  relaxed: integer can be modified but still points to valid object strict: integer not allowd to be modified.   Benchmarking 100MHz Stratix IV FPGA. DDR DRAM is faster then CPU, so cache misses are less costly.\n Olden. pointer intensive. Dhrystone. Less pointer intensive. tcpdump zlib  Code Changes\nLines of code changed to port from MIPS to CHERIv2 and CHERIv3   Annotation are manually added to understand their placement. But compiler can represent pointers using capalibities internally, avoiding the need for manual annotations.\n Semantic Changes:\n tcpdump on cheriv2: 1.6K lines to avoid pointer subtraction. tcpdump on cheriv3: 2 lines to mark readonly access to the packet being parsed rather then the whole packet buffer.  Compiler support:\n a new ABI in which all pointers are implemented as capabilities; references to on-stack objects are derived from a stack capability. zlib version 1: header annotation for compatability with MIPS ABI. A single pragma at the start and end of the library header. zlib version 2: copying structures when they are passed across the library boundary.   Overhead of CHERI-zlib normalized against zlib compiled for a conventional MIPS ISA  "
},
{
	"uri": "https://safersys.github.io/mm/en/pri-sep/",
	"title": "Automatic Privilege Separation",
	"tags": [],
	"description": "",
	"content": " Todos  Privtrans 3.2.2 and forward. 20190802  Top wonderings  How to automatically achieve privilege separation, or program partition, for as many partions as we need, and every partition has its least privilege?\n A maximum numbers of partitions possible to do automatically (minimum = no partition)?  How to find the number of partitions we actually need?\n How to determine the bounds of each partition, and the least privilege of a partition?\n How to define and restrict the communications between partitions?\n  Reference:\n PrivAnalyzer: Measuring the Efficacy of Linux Privilege Use  Reference: 2019 PrivAnalyzer1 PrivAnalyzer: Measuring the Efficacy of Linux Privilege Use. DSN, 2019 ↩  Glamdring: Automatic Application Partitioning for Intel SGX  Reference: Glamdring @ 2017ATC 1 Glamdring: Automatic Application Partitioning for Intel SGX. USENIX ATC, 2017. ↩  Secure web applications via automatic partitioning  Reference: Secure web @ 2007SOSP1. Secure web applications via automatic partitioning. SOSP, 2007. ↩  Privtrans: Automatically Partitioning Programs for Privilege Separation  References: Privtrans @ 2004SP1; Privilege separation in OpenSSH2; Partition a single program into two parts: a monitor, relegated all trust an privileges; a small TCB; a slave. Q \u0026amp; A What kind of static analysis techniques are used? What kind of dynamic analysis techniques are used? How to determine bounds of domain? How to define the interfaces between domains? Solution: Programmer annotations.\n "
},
{
	"uri": "https://safersys.github.io/mm/en/mem-safe/mmachine/",
	"title": "M-Mmachine",
	"tags": [],
	"description": "",
	"content": "References:\n[1] Hardware support for fast capability based addressing. SIGPLAN, 1994.\n[2] CHERI Concentrate: Practical Compressed Capabilities, IEEE Transactions on Computers, 2019.\nM-Machine Capability Format  "
},
{
	"uri": "https://safersys.github.io/mm/en/mem-safe/mpx/",
	"title": "Intel MPX",
	"tags": [],
	"description": "",
	"content": "Reference1\n referee ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/mem-safe/mpk/",
	"title": "Intel MPK",
	"tags": [],
	"description": "",
	"content": "References:\n[1] ERIM: Secure, Efficient In-process Isolation with Memory Protection Keys (MPK), SEC, 201908. paper\n"
},
{
	"uri": "https://safersys.github.io/mm/en/mem-safe/ssm/",
	"title": "SSM",
	"tags": [],
	"description": "",
	"content": "Reference1\n referee ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/mem-safe/sgx/",
	"title": "SGX",
	"tags": [],
	"description": "",
	"content": "Reference1\n referee ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/sys-sec/detection/",
	"title": "Detection",
	"tags": [],
	"description": "",
	"content": "Reference:\n Prima  PRIMA1: Info flow attestation. an extension to Linux IMA: measures the code (Linux IMA), and measures which information are present among processes. attest Biba and Clark-Wilson2, CW-Lite3; CW-Lite attestation is proved. Implementation: on SELinux. Info flow examples: Biba integrity requires that a process receive no input that is lower integrity than itself4. LOMAC(Low-Water Mark Integrity) requires that a process\u0026rsquo;s integrity be that of the lowest integrity input that it receives5.\n Flicker  Flicker1: 250 lines of code trusted; No trust on BIOS, OS, DMA devices. Trust processor (AMD/Intel) Fine-grained Attestation: e.g. A piece of server code handling the client password; no trust on all other softare stack from BIOS to OS. e.g. A Certificate Authority (CA) could sign certificates with its pricate key, even while keeping the key secret from a malicious BIOS/OS/DMA-enabled devices. Use of Flicker can be attested.\n Verifiable Code Execution  Pioneer1 Untrusted computing platform can tamper with code execution in at least three ways: By modifying the code before invoking it; Executing alternate code; or modifying execution state such as memory or registers when the code is running. Pioneer: challenge-response protocole between trusted \u0026amp; untrusted platform. Assuarance that: an arbitrary piece of code (the executable) on the untrusted platform is unmodified; the unmodified executable is invoked for execution on the untrusted platform; The exectable is executed untampered, despite the presence of malicious software on the untrusted platform.\n "
},
{
	"uri": "https://safersys.github.io/mm/en/sva/svaos/",
	"title": "SVA-OS",
	"tags": [],
	"description": "",
	"content": " References:\n2007-SOSP-SVA 1\n2009-SEC-SVA 2\nMemory Safety by kernel  C language memory safety in kernel\u0026rsquo;s code base Memory safety related functionality of the kernel  process states in trap/exceptions, including context switching. virtual/physical page mappings I/O memory, DMA memory   Idea of SVA-OS LLVA-OS is an interface prvoides \u0026ldquo;richer OS-information for hardware, greater flexibility in evolving hardware, and sophisticated analysis and optimization capabilities for kernel code\u0026rdquo;.\nQuestions/Proposals  Secure Virtual Architecture: A Safe Execution Environment for Commodity Operating Systems, SOSP, 2007. ↩ Memory Safety for Low-Level Software/Hardware Interactions, Usenix Security, 2009. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/cheri/cheriabi/",
	"title": "CheriABI",
	"tags": [],
	"description": "",
	"content": " Todos:\n what is the 1% of the C userspace not adapted to CHERI? Why?\n Lele: idiom violations/undefined behaviors; need manual change to be adapted.  How to prevent confused-deputy attacks via the kernel?\n How cheri generate dynamically linked programs?\n What is ABI\u0026rsquo;s relation with Compilers, OS, and architectures? What is ABI?\n  Motivation/Problems Problem of C C language is not safe.\n memory errors; injecting, manipulating, or abusing pointers in the run-time environment; explicit: declared data/code pointers; implicit: generated code to implement global variables (PIC, GOT, PLT) or return addresses; by the runtime to implement cross-library control flow.  How to protect C programs.\nProblem of MMU based protections  MMU:  process-granularity fault isolation. OS correct mappings. page granularity protection. No scale for fine-grain protection. e.g. for language-defined objects. often much smaller than a page or not sized in whole pages. No distinguish of virtual addr from arbitrary integers.   MMU\u0026rsquo;s granularity and address validation\nProblem of lastest research works C-language memory safety research:\nSoftware and hardware based mitigation techniques\n protect the integrity of pointers constrain control flow protect the code and data referenced by pointers  Examples:\n MPX\n Hardbound/SoftBound/FatPointers\n SAFECode/CETS\n  Cons:\ndisruptive:\n requiring large changes to existing codebases; using a unique OS or library infrastructure in stead of a full POSIX environment; being limited to statically linked code; lacking coverage in run-time libraries or kernels; incurring high performance costs.  Proposing:\n abstract capability: describes the accesses that should be allowed at a given point in the execution, whether in the kernel or userspace.\n a large-scale C-language software stack with strong pointer-based protection, with only modest changes to existing C codebases, and with reasonable performance cost.\n a complete C, C++, assembly-language software stack, including the open source FreeBSD OS, and PostgreSQL database, to employ ubiquitous capability-based pointer and virtual-address protection.\n  Two Key Challenges  capabilities are in terms of virtual addresses:\n with virtual-physical mapping, each capability allows direct access to a specific subset of physical memory; Mapping change overtime: when OS creates a new user process, maps additional memory, alters the backing of a mapping, or context switches to other address spaces.  diversity of pointers: created in a wide variety of ways; some of which require special intervention to preserve the provenance chain of abstract capabilities: paged out pointers; pointers in debugging mode.\n  Overview Two priciples1:\n Principle of least privilege. Principle of intentional use. An invoked privilege should be selected explicitly rather than implicitly.  The new CheriABI introduces a new process execution environment in which pure-capability CHERI code can be executed2.\nThe kernel expects all pointers passed via the system-call interface, and also other interfaces such as command-line arguments and environmental variable, ELF auxiliary arguments, signal handling, and so on, will also be via capabilities rather than MIPS pointers.\nThis feature can be enabled by compiling options COMPAT_CHERIABI into the kernel, but is currently considered experimental (2015 programmer\u0026rsquo;s guide2).\nMinimal privilege Memory accesses are not merely via arbitrary integers (checked against only the process address space), but also require an abstract capability, conferring an appropriate set of memory access permissions;\nProvenance Provenance in this paper is a series of correct operations like those we describe in 2019-POPL3, not to the attribution of errors as in Bond4.\nAbstract capabilities are constructed only by legitimate provenance chains of operations, successively reducing permissions from initial maximally permissive capabilities provided at machine reset; and code is not given access to excessive capabilities.\nWhole-system execution environment  Importantly, we aim to provides this across whole-system executions, not just within the C-language portion of user processes.\n Where pointers are constructed and manipulated:\n process creation; virtual memory including swapping; system calls; dynamic linking; context switching; signal delivery; debugging; a host of C-language operations.  Key Challenge: confused-deputy attacks via the kernel Virtual to physical mapping  Virtual to physical mapping: Each process get a principle ID\n prevent illegal access from another process.  Physical memory managed: a never-before-used addresses for allocation.\n prevent two different virtual address mapped to same physical address.   Swapping  maintain a swapping metadata that resides in memory and not swapped.  recording tags for each 256-bit memory that was swapped out. storing reconstructing the capability tags when swapped in.    \u0026ndash;\u0026gt; Kernel must have the full capability to reconstruct any capability during swapping in.\nThen how to constraint this part of kernel to have least privilege?\nDetailed ABIs Register usage    Register Compiler Usage     $v0 contains the method number for cross-domain calls.   $c0 Used implicitly for all non-capability memory accesses.   $c1 - $c16 Used for arguments in the \u0026ldquo;fast\u0026rdquo; calling convention.   $c1 - $c2 Code and data capability arguments with the ccall calling convention.   $c3 Capability return value.   $c3 - $c10 Capability arguments (caller-save).   $c11 Sack capability (pure-capability ABI).   $c12 Used with cjalr as the destination register (pure-capability ABI).   $c13 Capability to on-stack arguments (variadic functions only).   $c11 - $c15 Temporary (caller-save) registers.   $c17 Capability link register used with cjalr (pure-capability ABI).   $c16 - $c24 Saved (callee-save) registers.   $c25 - $c31 Not used by the compiler.    Two ABIs Cheri compiler supports two ABIs, an extended version of the MIPS n64 ABI and the pure-capability ABI where each pointer is a capability.\nMIPS ABI  use jalr $t9, $ra for function call.\n calling convention: add support of capability arguments\n $c3 - $c10 are passed as capability arguments, with $c3 also used for capability return values.  variadic calls does not support capability arguments.\n  Pure-capability ABI  use $c11 as stack capability. use cjalr $c12, $c17 for function call. use cjr $c17 for return. variadic calls: all arguments are passed on stack.  $c13 register holds a capability to the on-stack arguments. va_start function copies the value that was stored in $c13 on entry to the function. va_list is a capability to the (on-stack) variadic arguments and va_arg calls ensure correct alignment, load from the capability, and increment its offset past the value. The alignment requirements can result in large gaps in the variadic argument list if integer and capability arguments are inverleaved. extending use of $c13 for general range of on-stack arguments.   Cross-domain calls: ccall chericcallcc calling convention2: - use $c1 and $c2 for the first two capability arguments and $v0 for the method number. - frontend will lower structs to a sequence of scalars, which is generated from a two-capability struct.\n backend will track argument registers and return registers, zero unused ones.\n compiler generates two special sections, which libcheri runtime will leverage to match the cross domain calls.\n __cheri_sandbox_required_methods: metadata about methods that are required by the binary. __cheri_sandbox_provided_methods: metadata about methods that are provided by the binary.   The metadata struct for a method in __cheri_sandbox_provided_methods:\n// file: lib/libcheri/libcheri_sandbox_methods.c  /* * Description of a method provided by a sandbox to be called via ccall. * This data is used to create the \u0026#39;sandbox class\u0026#39; vtable, resolve symbols * to fill in caller .CHERI_CALLER variables, and store the corresponding * method numbers in the .CHERI_CALLEE variables of each \u0026#39;sandbox object\u0026#39;. */ struct sandbox_provided_method { char\t*spm_method;\t/* Method name */ vm_offset_t\tspm_index_offset;\t/* Offset of callee variable */ }; /* * List of methods provided by a sandbox. Sandbox method numbers (and * by extension vtable indexs) are defined by method position in the * spms_methods array. * * XXX: rename to sandbox_provided_class */ struct sandbox_provided_methods { char\t*spms_class;\t/* Class name */ size_t\tspms_nmethods;\t/* Number of methods */ size_t\tspms_maxmethods; /* Array size */ struct sandbox_provided_method\t*spms_methods;\t/* Array of methods */ }; /* * List of classes provided by a sandbox binary. Each binary can * support one or more classes. No two binaries can provide the same * class as vtable offsets would be inconsistant. */ struct sandbox_provided_classes { struct sandbox_provided_methods\t**spcs_classes;\t/* Class pointers */ size_t\tspcs_nclasses; /* Number of methods */ size_t\tspcs_maxclasses; /* Array size */ size_t\tspcs_nmethods; /* Total methods */ vm_offset_t\tspcs_base;\t/* Base of vtable */ }; The metadata struct for a method in __cheri_sandbox_required_methods:\n// file: lib/libcheri/libcheri_sandbox_methods.c  /* * Description of a method required by a sandbox to be called by ccall. */ struct sandbox_required_method { char\t*srm_class;\t/* Class name */ char\t*srm_method;\t/* Method name */ vm_offset_t\tsrm_index_offset;\t/* Offset of caller variable */ vm_offset_t\tsrm_vtable_offset;\t/* Method number */ bool\tsrm_resolved;\t/* Resolved? */ }; /* * List of methods required by a sandbox (or program). Sandbox objects * must not be created until all symbols are resolved. */ struct sandbox_required_methods { size_t\tsrms_nmethods;\t/* Number of methods */ size_t\tsrms_unresolved_methods; /* Number */ struct sandbox_required_method\t*srms_methods;\t/* Array of methods */ }; Example header dumped from cheri_tcpdump:\nAssumptions:\n os/lib assumption: they will zero/preserve all non-argument registers across security domain transitions. float assumption: always used and not cleared; need revisiting.  see cheri domain for more details about ccall.\nGlobal initialization  \u0026ldquo;Capabilities cannot be statically defined in the binary as other data, because doing so will not set the tag.\u0026rdquo;\n What if we have tags in the binary file, i.e. on the disk storage?   A new section in ELF binary: __cap_relocs, which contains instances of the capreloc structure, one for each capability.\nstruct capreloc { void *__capability capability_location; void *object; uint64_t offset; uint64_t size; uint64_t permissions; };  capability_location: relative address of the capability that must be initialized at run time; object: address of the object that the capability refers to. offset: offset within this object. size: size of underlying object.  For example, the code\nextern int a[5]; int *b[] = {\u0026amp;a[2], \u0026amp;a[1], a}; will be compiled to the following three structures in the ELF:\n{ \u0026amp;b[0], \u0026amp;a, 8, 0, 0}, { \u0026amp;b[1], \u0026amp;a, 4, 0, 0}, { \u0026amp;b[2], \u0026amp;a, 0, 0, 0} The size is 0 and will be reset after linking.\n Limitations (in 2015, programmer\u0026rsquo;s guide):\n should have a flag to indicate code or data capability. have no way of enforcing permissions. dynamically linked binaries will need a run-time linker to provide symbol sizes.   Return address protection In the pure-capability ABI, return address is a $pcc-relative capability.\n If overwritten with non-capability, will trigger tag violation. If overwritten by a non-executable capability, will trigger a permission violation.  A success attack, will have to\n find an executable capability trick the program into writing over the return address  In the MIPS ABI, return sequence is modified:\n non-leaf functions, when spill return address, also spill a return capability: $pcc with its offset to the return address. use cjr to return. still spill the return address for compatability (some tools rely on the position of the return address on the stack).   RISC architectures typically provide a jump instruction that puts the return address in another register (e.g. jalr on MIPS, bl[x] on ARM). If the called function calls another function, it must spill return address to the stack, where it can be reloaded later.\n  CheriABI: Enforcing Valide Pointer Provenance and Minimizinig Pointer Privilege in the POSIX C Run-time Environment, ASPLOS, 2019. ↩ CHERI Programmer\u0026rsquo;s Guide, 2015. ↩ Exploring C Semnatics and Pointer Provenance. POPL 2019. ↩ Tracking Bad Apples. OOPSLA, 2007. It tracks the origin using metadata stores the origin infomation and reports the origin of null and undefined value errors. It shows how to record where these values come into existence, correctly propagate them, and report them if the cause an error. The key idea is value piggybacking: when the original program stores an unusable value, value piggybacking instead stores origin information in the spare bits of the unusable value. Modest compiler support alters the program to propagate these modified values through operations such as assignments and comparisons. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/sva/hwsw/",
	"title": "Memory Safety in Hardware and Software Interactions",
	"tags": [],
	"description": "",
	"content": " Secure HW/SW Interface  Motivation OS memory safety research Memory safety for OS code: OS designs based on safe languages; Compiler techniques such as SVA-M to enforce memory safety for commodity OSs in unsafe languages; Instrumentation techniques to isolate a kernel from extensions such as device drivers; Singularity, SPIN, JX, JavaOS, SafeDrive, and SVA-M are examples of system that enforce a safe execution environment. Common asumptions of OS memory safety research Unfortunately, all these memory safety techniques (except Verve, which has very limited I/O and no MMU support) make assumptions that are routinely violated by low-level initeractions between an OS kernel and hardware, even if implemented in safe programming language.\n KCoFI  Reference1 referee ↩  Reference1\n referee ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/prog-ana/",
	"title": "Program Analysis",
	"tags": [],
	"description": "",
	"content": "  Interprocedural  Ch12 of Dragon Book1. Intra-procedural Analysis Most compiler optimizations are performed on procedures one at a time. We refer to such analyses as intraprocedural. These analyses conservatively assume that procedures invoked may alter the state of all the variables visible to the procedures and that they may create all possible side effects, such as modifying any of the variables visible to the procedure or generating exceptions that cause the unwinding of the call stack.\n Pointer Analysis   References: [] Pointer Analysis: Haven\u0026rsquo;t we solved this problem yet? PASTE, 2001. Questions/Proposals A least restricted language that allows sound and complete point-to analysis. How to handle recursive data structures?  Complexity  Reference: References: [1] Static Program Analysis, Anders Moller, and Micheal I. Schwartzbach, 2018. Questions/Proposals To decide whether any given a program will halt or not is undecidable. However, there are many programs (probably small or large) that we already know it will halt, or will never halt. How many are there? What is the common feature of these programs? Could we statically describe some (not all) of them? Undecidability of Program Correctness\n Fm  Reference: Hott Reference1 \u0026ldquo;Homotopy Type Theory: Univalent Foundations of Mathematics\u0026rdquo;. ↩  "
},
{
	"uri": "https://safersys.github.io/mm/en/sva/vghost/",
	"title": "Virtual Ghost",
	"tags": [],
	"description": "",
	"content": "Reference:\n "
},
{
	"uri": "https://safersys.github.io/mm/en/cheri/cheri-cc/",
	"title": "Cheri Concentrate",
	"tags": [],
	"description": "",
	"content": " Overview Cheri Concentrate(CC) is a compression scheme applied to CHERI. CC achieves the best published region encoding efficiency, solves important pipeline problems caused by a decompressed register file.\nProblem The object bounds and permission information encoded in capability pointers cause the largest overhead among all overheads. Thus need a new encoding scheme to reduce overhead, i.e a method for compression and decompression.\nChallenge  Pipeline optimization in terms of the hardware changes for the encoding scheme. Minimize the delay of bound checking for integration with standard processor designs. Minimize the semantic restrictions to support legacy code.  Solution  Floating-point bounds encoding. Full toolchain support: compilers, binaries, runtime environment. Representable Region with power-of-two bounds, beyonds object bounds. Representability Check with low delay, comparable to a pointer add.  Design "
},
{
	"uri": "https://safersys.github.io/mm/en/sva/intrin/",
	"title": "Intrinsics",
	"tags": [],
	"description": "",
	"content": "Reference:\n "
},
{
	"uri": "https://safersys.github.io/mm/en/sys-sec/",
	"title": "System Security",
	"tags": [],
	"description": "",
	"content": "Reference:\n Security Policies  PORTIA: Of a strange nature is the suit you follow; Yet in such rule that the Venetian law Cannot impugn you as you do proceed. [To Antonio.] You stand within his danger, do you not? \u0026ndash; The Merchant of Venice, IV, i, 177\u0026ndash;180\n Attacks  Reference: Privilege Escalation Reference: Container Privilege Escalation Reference: DOP Jujutsu References: [1] Control Jujutsu: On the Weaknesses of Fine-Grained Control Flow Integrity. CCS, 2015. A new attack on fine-grained CF that exploit the incompleteness of pointer analysis, when combined with common software engineering practices, to enable an attacker to execute arbitrary malicious code. Concepts: ICS: Indirect Call Site ACICS: Argument Corruptible Indirect Call Site RCE: Remote Code Execution DSA: Data Structure Analysis DEP: Data Execution Prevention ASLR: Address Space Layout Randomization SSP: Stack Smashing Protection ROP: Return-oriented Programming JOP: Jump-Oriented Programming Threat Model The threat model in this paper is a remote attacker trying to hijack control of a machine by exploiting memory vulnerabilities.\n Defences  Reference: Tamper Resistant Software Design and Implementation: IVK Paper1: Make software immune to observation and modification. Tamper-resistance using Integrity Verification Kernels: segments of code which are self-modifying, self-decrypting and installation unique. code segments communicates with other such code, creating an interlocking trust model. Threats: breach communication access controls to attack the system; computer virus; attacker as insider: may modify at will. Tamper Resistant Software Design and Implementation. 1999. ↩ Info Flow Integrity Reference:  Detection  Reference: Prima PRIMA1: Info flow attestation. an extension to Linux IMA: measures the code (Linux IMA), and measures which information are present among processes. attest Biba and Clark-Wilson2, CW-Lite3; CW-Lite attestation is proved. Implementation: on SELinux. Info flow examples: Biba integrity requires that a process receive no input that is lower integrity than itself4. LOMAC(Low-Water Mark Integrity) requires that a process\u0026rsquo;s integrity be that of the lowest integrity input that it receives5.\n "
},
{
	"uri": "https://safersys.github.io/mm/en/cheri/cheri-kernel/",
	"title": "Cheri Kernel",
	"tags": [],
	"description": "",
	"content": " References:\n[1] CHERI ISA v5 (2016), v6(2017), v7 (2019).\n[2] CheriBSD, github, link.\n 2016 v5: Initial in-kernel privilege limitation\n 2017 v6: Mature kernel privilege limitation\n  [3] CHERI programmer\u0026rsquo;s guide, UCAM-CL-TR-877, 2015.\nQuestions/Proposals  Kernel has no capability state during context switch: kernel state\n How does CheriBSD do memory partition for physical memory tags?\n  In details  Kernel Capability\n Kernel Change List\n CheriBSD Context Switch\n Trusted Stack\n Signal Handling\n Copying Memory\n CheriABI\n  "
},
{
	"uri": "https://safersys.github.io/mm/en/cheri/cheri-user/",
	"title": "Cheri Userspace",
	"tags": [],
	"description": "",
	"content": " Change List  libprocstat(3) library and procstat(1) command: extended to inspect sandbox statistics.\n libcheri(3): a sandbox API, and a set of system-class objects that can be delegated to sandboxes. Currently (1), this consists of a singleton system object that provides the ability to print to stdout, and a file-descriptor class that allows delegation of individual kernel-provided file descriptors to sandboxes.\n libc_cheri(3): core C-language APIs and services within sandboxes. This library is able to use the system and file-descriptor classes to provide access to APIs such as printf().\n cheritest: test cases for capability-related functions including sandboxing; cheritest relies on cheritest-helper.bin to provide sandboxed code.\n cheri_tcpdump, sandboxed sniffing and parsing; cheri_tcpdump relies on tcpdump-helper to provide sandboxed code.\n libz-cheri(3): compression routines with fine-grained memory protection.\n  Source code CheriBSD userspace source directories:\n   Filename Description     bin/cheritest/ Command-line utility exercising CHERI and CheriBSD features, including sandboxing CTSRD-project demo code   ctsrd/ CTSRD-project demo code   lib/libc_cheri/ In-sandbox C library/runtime   lib/libcheri Library implementing the CHERI sandbox API; the CHERI system class implementation   libexec/cheritest-helper/ Sandboxed components for cheritest   libexec/tcpdump-helper/ Sandboxed components for cheri_tcpdump, initialization and context management   lib/libz-cheri Version of libz compiled with CHERI memory protection   usr.sbin/tcpdump/cheri_tcpdump Version of tcpdump able to use CHERI sandboxing   lib/libprocstat/ Extensions to this library allow procstat(1) to monitor libcheri sandboxes   usr.bin/procstat/ procstat(1) command extended to monitor libcheri sandboxes     CHERI programmer\u0026rsquo;s guide, 2015. (may be outdated) ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/cheri/hacking/",
	"title": "Hacking",
	"tags": [],
	"description": "",
	"content": "Reference:\nQuick pinning CHERI source, good for both lib and kernel:\n__has_feature(capabilities), used in sys/, bin/, lib/, libexec/, contrib/, include/, stand/, and *.h, *.c;\ndefined(__CHERI__), used in sys/, lib/, contrib/, and *.h, *.c, *.S;\n "
},
{
	"uri": "https://safersys.github.io/mm/en/compilers/",
	"title": "Compilers",
	"tags": [],
	"description": "",
	"content": "Reading list:\n Build A Simple Interpreter\n Books:\n \u0026ldquo;Optimizinig Compilers for Modern Architectures: A Dependence-based Approach\u0026rdquo;. By Randy Allen, and Ken Kennedy. 2001. \u0026ldquo;Compilers: Principles, Techniques, and Tools\u0026rdquo;. By Alfred V. Aho, Monica S. Lam, Ravi Sethi, and Jeffrey D. Ullman. 2nd ed. 2007. \u0026ldquo;Advanced Compiler Design and Implementation\u0026rdquo;. By Steven S. Muchnick. 1997. \u0026ldquo;Engineering A Compiler\u0026rdquo;. By Keith D. Cooper, and Linda Torczon. 2nd ed. 2012.    Backend   Reference: Tutorial: Creating an LLVM Backend for the Cpu0 Architecture MIPS call  "
},
{
	"uri": "https://safersys.github.io/mm/en/prog-ana/complexity/",
	"title": "Complexity",
	"tags": [],
	"description": "",
	"content": " Reference:\nReferences:\n[1] Static Program Analysis, Anders Moller, and Micheal I. Schwartzbach, 2018.\nQuestions/Proposals  To decide whether any given a program will halt or not is undecidable. However, there are many programs (probably small or large) that we already know it will halt, or will never halt. How many are there? What is the common feature of these programs? Could we statically describe some (not all) of them?   Undecidability of Program Correctness  \n "
},
{
	"uri": "https://safersys.github.io/mm/en/prog-ana/fm/",
	"title": "Fm",
	"tags": [],
	"description": "",
	"content": "Reference:\n Hott  Reference1 \u0026ldquo;Homotopy Type Theory: Univalent Foundations of Mathematics\u0026rdquo;. ↩  "
},
{
	"uri": "https://safersys.github.io/mm/en/sva/safecode/passes/",
	"title": "Passes",
	"tags": [],
	"description": "",
	"content": " Stack Check  Reference1 safecode/include/StackSafety.h: This file defines checks for stack safety. struct checkStackSafety : public ModulePass { public : ... virtual bool runOnModule(Module \u0026amp;M); virtual void getAnalysisUsage(AnalysisUsage \u0026amp;AU) const { AU.addRequired\u0026lt;DataLayout\u0026gt;(); AU.addRequired\u0026lt;EQTDDataStructures\u0026gt;(); AU.setPreservesAll(); } private : // // Tracks the DSNodes that have already been analyzed by an invocation of // markReachableAllocas(). // std::set\u0026lt;DSNode *\u0026gt; reachableAllocaNodes; bool markReachableAllocas(DSNode *DSN, bool start=false); bool markReachableAllocasInt(DSNode *DSN, bool start=false); }; } } safecode/lib/StackSafety/CheckStackPointer.\n Static Array Bound Checks  lib/ArrayBoundChecks: This library contains serveral analysis passes for static array bounds checking1. safecode/lib/ArrayBoundChecks/ArrayBoundCheckLocal.cpp: \u0026ldquo;ArrayBoundsCheckLocal - It tries to prove a GEP is safe only based on local information, that is, the size of global variables and the size of objects being allocated inside a function.\u0026rdquo; Code sinppets: Entry: bool ArrayBoundsCheckLocal::runOnFunction(Function \u0026amp; F) { // // Get required analysis passes. // TD = \u0026amp;F.getParent()-\u0026gt;getDataLayout(); SE = \u0026amp;getAnalysis\u0026lt;ScalarEvolution\u0026gt;(); // // Look for all GEPs in the function and try to prove that they\u0026#39;re safe.\n Pass: Insert Pointer Checks  Reference1 C Zero Security Checks: \u0026ldquo;This transformation ensures that the code emitted (if there are no warnings) poses no security threat to the target system.\u0026rdquo; Free Removal Pass: \u0026ldquo;FIXME: This pass needs to be cleaned up and better understood. Some of the functionality seems to be addressed with poolcheckalign() in the Check Insertion pass; we should ensure that the functionality there is present in mainline and supercedes what is implemented here.\n Pass: Insert Pool Checks  lib/InsertPoolChecks. This library contains the transform passes for inserting run-time checks and for inserting code to register memory objects within individual pools. the CompleteChecks pass which implements the Check Completion Phase. Alignment Checks: \u0026ldquo; This pass instruments the code with alignment checks. This is required when load/store checks on type-safe memory objects are optimized away; pointers to type-safe memory objects that are loaded from type-unsafe memory objects may not point to a valid memory object or may not be alignment properly within a valid memory object.\n "
},
{
	"uri": "https://safersys.github.io/mm/en/os/linux/",
	"title": "Linux",
	"tags": [],
	"description": "",
	"content": "Reference1\n referee ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/os/",
	"title": "OS",
	"tags": [],
	"description": "",
	"content": "  L4  Reference: L4 kernel projects seL4: from Data61 OKL4: from Open Kernel Lab  OS in Rust  Reference: Writing an OS in Rust  Gnu Hurd  GNU Hurd Reference1 referee ↩  Freebsd  Reference1 referee ↩  Minix 3  Minix Minix 3 Reference1 referee ↩  Linux  Reference1 referee ↩  "
},
{
	"uri": "https://safersys.github.io/mm/en/cheri/cheri-fm/",
	"title": "Cheri Formal",
	"tags": [],
	"description": "",
	"content": " References:\n[1] CHERI ISA v5 (2016).\n Existing formal methodology applied to software security has significant problems with multi-address-space security models; formal approaches have relied on the usefullness of addresses(pointers) as unique names for objects. Whereas this weakness in formal methods is a significant problem for traditional CPU designs, which offser security primarily through rings and address-space translation, CHERI\u0026rsquo;s capability model is scoped within address spaces. This offers the possibility of applying existing software proof methodology in the context of hardware isolation (and other related properties) in a manner that was previously infeasible.\n\u0026ndash; Formal Methodology, CHERI ISA v5, chapter 1.6.\n Questions/Proposals "
},
{
	"uri": "https://safersys.github.io/mm/en/cheri/cheri-link/",
	"title": "Cheri Link",
	"tags": [],
	"description": "",
	"content": "archetypes learning.md\n"
},
{
	"uri": "https://safersys.github.io/mm/en/arch/",
	"title": "Arch",
	"tags": [],
	"description": "",
	"content": "Reference:\n "
},
{
	"uri": "https://safersys.github.io/mm/en/langs/",
	"title": "Languages",
	"tags": [],
	"description": "",
	"content": "Reference:\n NesC  Reference:  Aspect Oriented Programming  Reference: what is aop  Go  Reference: Concurrency Setup Environment Variables Reference: GOPATH: environment variable that specifies the location of your workspace. If no GOPATH is set, it is assumed to be $HOME/go on Unix systems and %USERPROFILE%\\go on Windows. more Binary Package Download Getting Started with Go Build from Source Install Go from Source Uninstalling Go delete go directory. usually /usr/local/go under Unix or c:\\Go on Windows. remove Go bin directory from the $PATH environment variable.\n Rust  Reference:  Proof Carrying Code  PCC @ POPL\u0026rsquo;97 1, Necula Thesis\u0026rsquo;98 2. Proof-Carrying Code. George C. Necula. POPL, 1997. ↩ Compiling with Proofs. PhD thesis by George Ciprian Necula. 1998. ↩  Typed Assembly Language  Reference:  "
},
{
	"uri": "https://safersys.github.io/mm/en/mem-safe/ripe/",
	"title": "RIPE: Runtime Intrusion Prevention Evaluator",
	"tags": [],
	"description": "",
	"content": " 850 buffer overflow attack forms.\n RIPE 1 extends 2003 NDSS 2 paper from 20 attack forms to 850 attack forms.\nDimensions Location of the buffer in memory, target code pointer, overflow technique,\nD1: Location  Stack Heap BSS segment Data segment  D2: Target Code Pointer  Return address Old base pointer: The previous contents of the EBP register, which is used to reference functin arguments and local variables Functino pointers: Generic function pointers allowing programmers to dymanically call different functions from the same code Longjmp buffers: Setjmp/longjmp is a technique which allows programmers to easily jump back to a predefined point in their code. Vulnerale Structs: Structs which group a buffer and a function pointer and can be abused by attackers to overflow from one to the other.  D3: Overflow Technique  Direct overflow: target is adjacent to the overflowed buffer, or can be reached by sequentially overflowing from the buffer. Idirect overflow: use generic pointers to store target address, and overwrite the target with attack-controlled data. Such as ones used to bypass StackGuard canary.  D4: Attack Code  Shellcode without NOP sled: This option can be useful in testing the accuracy of attacks as well as challenge countermeasures that rely on the detection of specific code patterns (such as the presence of a set of 0x90 bytes (NOP)) in the process\u0026rsquo; address space. Shellcode with NOP sled: This is the most-used form of shell code that prepends the attacker\u0026rsquo;s functionality with a set of NO-oPeration instructions to improve the attacker\u0026rsquo;s chances of correctly redirecting the execution-flow of the program into his injected code. Shellcode with polymorphic NOP sled: In this case, the NOP sled is not the standard set of 0x90 bytes but a set of instructions that can be executed without affecing the correctness of the actual attack code. Akritidis et al. 3 conducted a study where, among others, they showed how obfuscation and encryption can be used by attackers to evade Network Intrusion Detection Systems (NIDS). Return-into-libc: e.g. using the system libc function to execute an interactive shell. RIPE uses system() for the spawning of an interactive shell and creat() for creating new files. ROP: ROP is the generalization of Return-into-libc, where chunks of functionality from existing code (gadgets) and combine them to create new functionality. RIPE implements a ROP attack, but does not implement stack-pivoting techniques.  D5: (n-contain) function Abused A user can choose to perform mthe buffer overflow with memcpy(), strncpy(), sprintf(), snprintf(), strcat(), strncat(), sscanf(), fscanf(), and also with \u0026ldquo;homebrew\u0026rdquo;, a loop-based equivalent of memcpy.\nn-containing functions are designed to take the target buffer size into account which should prevent buffer overflows. The size however, is provided by the developer (static or calculated) and thus a miscalculation can cancel-out the protection offered by these functions.\nKnown caveats include the fact that parameter n means total buffer size for strncpy() but remaining buffer space for strncat()4, and if n is undefined for instance because of a NULL value in the length caculation strncpy() will allow for buffer overflow as shown in CVE-2009-40355:\nline1 = getNext(line); // May return NULL if ((n=line1 -line) \u0026gt; 255) { n = 255; } strncpy(buf, line, n); // n undef or \u0026lt; 0 RIPE: Runtime Intrusion Prevention Evaluator. ACSAC, 2011. ↩ A comparative study of publicly available tools for dynamic buffer overflow prevention. NDSS, 2003. ↩ Akritidis et al. Stride: Polymorphic sled detection through instruction sequence analysis. 2005. ↩ Howard, M. Evils of strncat and strncpy - Answers. http://blogs.msdn.com/b/michael_howard/archive/2004/12/10/279639.aspx ↩ CVE-2009-4035 [22] ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/cheri/cheri-isa/",
	"title": "Cheri ISA Semantic",
	"tags": [],
	"description": "",
	"content": " References:\n[1] ISA Semantics for ARMv8-A, RISC-V, and CHERI-MIPS. POPL, 2019\nBasiscs Architecture specifications define the fundamental interface between hardware and software: the envelope of allowd behaviour for processor implementations, and the basic assumtions for software development and verification.\n In practise, they are typically prose and pseudocode documents, not rigorous or executable artifacts, leaving software and verification on shaky ground.  Sail: an ISA semantic language with dependent type system.\n supports automatic generation of emulator code in C and OCaml; automatic generation of proof-assistant definitions for Isabelle, HOL4, and (currently only for MIPS) Coq.  Overview A rigorous semantic models for the sequential behaviour of large parts of mainstream ARMv8-A, RISC-V, and MIPS archtitectures, and the research CHERI-MIPS architecture.\n These architectures are complete enough to boot operating systems, variously Linux, FreeBSD, or seL4.\n ISA semantics defined in Sail.\n Sail definition for validation;\n Sail definition to assess specification coverage.\n Functional correctness proof in Isabelle, for ARMv8-A address translation.\n RMEM tool for (user-mode) relaxed-memory concurrency exploration, of RISC-V model.\n Proof of the soundness of the core Sail type system.\n  Questions/Proposals A semantic for os-app interactions?\n POSIX, libc? ABI?  "
},
{
	"uri": "https://safersys.github.io/mm/en/langs/proofcc/",
	"title": "Proof Carrying Code",
	"tags": [],
	"description": "",
	"content": "PCC @ POPL\u0026rsquo;97 1, Necula Thesis\u0026rsquo;98 2.\n  Proof-Carrying Code. George C. Necula. POPL, 1997. ↩ Compiling with Proofs. PhD thesis by George Ciprian Necula. 1998. ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/langs/typedas/",
	"title": "Typed Assembly Language",
	"tags": [],
	"description": "",
	"content": "Reference:\n "
},
{
	"uri": "https://safersys.github.io/mm/en/sva/hwsw/kcofi/",
	"title": "KCoFI",
	"tags": [],
	"description": "",
	"content": "Reference1\n referee ↩   "
},
{
	"uri": "https://safersys.github.io/mm/en/research/",
	"title": "Research",
	"tags": [],
	"description": "",
	"content": "Reference:\nIncreasing your research impact\n Taxonomies organize a problem or existing solutions into \u0026ldquo;boxes\u0026rdquo; that can expose new opportunites. Mendeleev\u0026rsquo;s Periodic Table that focused efforts on uncovering missing elements.\n Connections are key to research. Steve Jobs said, \u0026ldquo;Creativity is just connecting things.\u0026rdquo; Don\u0026rsquo;t unduly worry about dividing credit, but generously share credit as it often multiplies and leads to collaborations that can enable something even more worthwhile. \u0026ldquo;Sequential Consistency (SC) for Data-Race-Free (DRF) Programs\u0026rdquo; memory model is the result of a connection between data races and weak/relaxed memory models.\n  How to have a bad career\n Paper Writing  Excellent Sampes: Portable Native Client @ USENIX Security 20101 Adapting Software Fault Isolation to Contemporary CPU Architectures. USENIX SEC, 2010. ↩  "
},
{
	"uri": "https://safersys.github.io/mm/en/practice/",
	"title": "Practice",
	"tags": [],
	"description": "",
	"content": "Reference:\n 编程之美  《编程之美》1 一句话：关键不在于答案，而在于思考问题的方法。 知己知彼：了解公司的文化、战略方向。 笔试是基础，需要扎实的理解和考虑完备的解答。\n "
},
{
	"uri": "https://safersys.github.io/mm/en/cheri/cheri-domain/sandbox-loader/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://safersys.github.io/mm/en/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://safersys.github.io/mm/en/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://safersys.github.io/mm/en/",
	"title": "Welcome",
	"tags": [],
	"description": "",
	"content": " Welcome ! Hellooo! Here is hosted my reading notes! I will try to keep them organized. However, they will look like memory flakes since my interests keep changing and expanding.\nTodos  What is proof carrying code? How to generate such code? How to remove Compilers from trusted computing base? When compiler are heavily used for security solutions?\n Automatic program partition for privilege separation?\n  Book Shelf Math.FM. \u0026ldquo;Logical Foundations for Computing Science\u0026rdquo;. By Shen Enshao. 2006.\n\u0026ldquo;Logic for Computer Science.\u0026rdquo; By Steve Reeves and Mike Clarke. 2003.\n\u0026ldquo;Homotopy Type Theory: Univalent Foundations of Mathematics\u0026rdquo;. The Univalent Foundations Program, 2013.\nComplexity \u0026ldquo;Introduction to Automata Theory, Languages, and Computation\u0026rdquo;. By John E. Hopcroft, Rajeev Motwani, and Jeffery D. Ullman. 2006.\n\u0026ldquo;Computers and Intractability: A Guide to the Theory of NP-Completeness\u0026rdquo;. By Micheal Garey and David S. Johnson. 1979.\nAlgorithms \u0026ldquo;Introduction to Algorithms\u0026rdquo;. By Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. 2009.\n\u0026ldquo;The Art of Multiprocessor Programming\u0026rdquo;. By Maurice Herlihy, and Nir Shavit. 2008.\nProgram Analysis \u0026ldquo;Principles of Program Analysis\u0026rdquo;. By Flemming Nielson, Hanne Riis Nielson, and Chris Hankin. 1998.\nLanguages \u0026ldquo;Types and Programming Languages\u0026rdquo;. By Benjamin C. Pierce. 2002.\n\u0026ldquo;Advanced Topics in Types and Programming Languages\u0026rdquo;. By Benjamin C. Pierce, editor. 2004.\n\u0026ldquo;Practical Foundations for Programming Languages\u0026rdquo;. By Robert Harper. 2012.\nCom.Arch \u0026ldquo;Computer Organization and Design, The Hardware/Software Interface\u0026rdquo;. By David A. Patterson, and John L. Hennessy. 5th ed. 2014.\n\u0026ldquo;Computer Architecture: A Quantitative Approach\u0026rdquo;. By John L. Hennessy, and David A. Patterson. 5th ed. 2012.\nCom.Sys \u0026ldquo;Computer Systems: A Programmer\u0026rsquo;s Perspective\u0026rdquo;. By Randal E. Bryant, and David R. O\u0026rsquo;Hallaron. 3rd ed, 2015.\n\u0026ldquo;The Design and Implementation of the FreeBSD Operating System\u0026rdquo;. By Marshall Kirk McKusick, George V. Neville-Neil, and Robert N.M. Watson, 2nd ed, 2014.\n\u0026ldquo;Understanding the Linux Kernel\u0026rdquo;. By Daniel P. Bovet, and Marco Cesati. 3rd ed. 2005.\nCompilers \u0026ldquo;Compilers: Principles, Techniques, and Tools\u0026rdquo;. By Alfred V. Aho, Monica S. Lam, Ravi Sethi, and Jeffrey D. Ullman. 2nd ed. 2007.\n\u0026ldquo;Advanced Compiler Design and Implementation\u0026rdquo;. By Steven S. Muchnick. 1997.\n\u0026ldquo;Engineering A Compiler\u0026rdquo;. By Keith D. Cooper, and Linda Torczon. 2nd ed. 2012.\n\u0026ldquo;Optimizinig Compilers for Modern Architectures: A Dependence-based Approach\u0026rdquo;. By Randy Allen, and Ken Kennedy. 2001.\nSoftware Programming Practice \u0026ldquo;Design Patterns: Elements of Reusable Object-Oriented Software\u0026rdquo;. By GoF, 1994.\n《编程之美\u0026ndash;微软技术面试心得》，电子工业出版社，2008。\nUpdate History    Date Description     Thu, 15 Aug 2019 00:11:03 EDT(-0400) deploy   Thu, 15 Aug 2019 00:10:43 -0400 intro uxom    Wed, 14 Aug 2019 23:55:03 -0400 to read usfi    Wed, 14 Aug 2019 22:56:31 -0400 update deploy script    Wed, 14 Aug 2019 22:13:13 -0400 create embed/; move nesCheck and uxom; create minion    Wed, 14 Aug 2019 22:12:30 -0400 add langs: tal; nesC    Wed, 14 Aug 2019 20:51:11 -0400 test    Wed, 14 Aug 2019 20:17:02 -0400 nesCheck    Wed, 14 Aug 2019 00:48:06 -0400 pnacl: to do x86-64    Wed, 14 Aug 2019 00:41:58 -0400 guard page    Wed, 14 Aug 2019 00:35:53 -0400 impl on arm    Tue, 13 Aug 2019 23:07:02 -0400 deplpy.sh: update history format: markdown table    Tue, 13 Aug 2019 22:26:07 -0400 data mask in pnacl    Tue, 13 Aug 2019 21:29:00 -0400 pnacl motivation    Tue, 13 Aug 2019 16:53:45 -0400 nacl resource descriptor for shared memory objects, etc.    Tue, 13 Aug 2019 16:27:50 -0400 native client: pcc    Tue, 13 Aug 2019 16:27:26 -0400 to read: pcc    Tue, 13 Aug 2019 15:14:39 -0400 one more book    Tue, 13 Aug 2019 00:49:54 -0400 tamper resistant: IVK to read;    Tue, 13 Aug 2019 00:39:46 -0400 tamper resistant software    Tue, 13 Aug 2019 00:28:02 -0400 prima: info flow integrity attestation/detection    Mon, 12 Aug 2019 23:54:26 -0400 rename secPol to security-pol    Mon, 12 Aug 2019 23:45:28 -0400 rename folders back with no upper letter flicker 2008 eurosys       Mon, 12 Aug 2019 23:16:00 -0400 add sys sec in general    Mon, 12 Aug 2019 22:59:47 -0400 rename top folders    Mon, 12 Aug 2019 22:59:24 -0400 rootkit detection    Mon, 12 Aug 2019 22:34:57 -0400 native client    Mon, 12 Aug 2019 22:34:05 -0400 privilege escalation papers    Mon, 12 Aug 2019 16:40:26 -0400 last mod date    Mon, 12 Aug 2019 16:39:42 -0400 useful links for basic research methods    Mon, 12 Aug 2019 16:39:21 -0400 nacl: original    Sat, 10 Aug 2019 21:50:17 -0400 comment out the last mod date    Sat, 10 Aug 2019 21:48:09 -0400 vg and sva intrinsics    Sat, 10 Aug 2019 21:47:18 -0400 add container pe    Sat, 10 Aug 2019 21:38:13 -0400 add new category attacks/    Sat, 10 Aug 2019 15:22:22 -0400 moving website to safersys.github.io    Thu, 8 Aug 2019 09:47:59 -0400 rename ChangeLog.html back to .txt    Thu, 8 Aug 2019 00:08:59 -0400 add keys to search for cheri feature;remove web_commits.log;    Wed, 7 Aug 2019 23:25:25 -0400 change delpoy.sh; only keep history in public html; but no history in hugo source index page    Wed, 7 Aug 2019 23:01:43 -0400 rename ChangeLog.txt to .html    Wed, 7 Aug 2019 22:55:43 -0400 write message to index with reset 2    Wed, 7 Aug 2019 22:51:54 -0400 move to memflakes.github.io    Wed, 7 Aug 2019 17:47:21 -0400 add creation data; add author, commented out now;    Wed, 7 Aug 2019 00:11:41 -0400 backed tutorial link    Tue, 6 Aug 2019 23:11:04 -0400 update script: change history before stage    Tue, 6 Aug 2019 23:10:26 -0400 update script: change history before stage    Tue, 6 Aug 2019 23:08:42 -0400 update script: change history before stage    Tue, 6 Aug 2019 22:39:43 -0400 no drafts    Sun, 4 Aug 2019 21:15:53 -0400 todo for compilers    Sun, 4 Aug 2019 19:58:00 -0400 go setup/tour pub    Sun, 4 Aug 2019 15:48:22 -0400 tour 01: functions variables types and packages    Sun, 4 Aug 2019 13:54:35 -0400 setup of golang    Fri, 2 Aug 2019 16:45:23 -0400 cheri-c-model in new folder; l4 os, minix original    Fri, 2 Aug 2019 09:54:34 -0400 add dinosaur book    Fri, 2 Aug 2019 09:27:41 -0400 put lastest 100 lines of change history to home page    Fri, 2 Aug 2019 09:15:54 -0400 privtrans to 3.2.2    Thu, 1 Aug 2019 14:38:39 -0400 privtrans ch2: annotation and policies    Wed, 31 Jul 2019 15:46:54 -0400 privtrans:ch1    Wed, 31 Jul 2019 15:46:14 -0400 colored/one more bar for comments    Wed, 31 Jul 2019 12:20:44 -0400 overall of privtrans    Wed, 31 Jul 2019 11:53:42 -0400 fix a broken link    Wed, 31 Jul 2019 11:35:06 -0400 add pageComments variable    Wed, 31 Jul 2019 10:55:32 -0400 a more general title automatic privilege separation    Wed, 31 Jul 2019 10:35:13 -0400 automatic compartmentalization    Wed, 31 Jul 2019 10:33:06 -0400 todo PrivAnalyzer to read    Wed, 31 Jul 2019 10:28:35 -0400 pp ask: auto determine least privilege    Wed, 31 Jul 2019 10:27:59 -0400 comments on every page    Wed, 31 Jul 2019 10:03:32 -0400 new todo: prog.partition    Wed, 31 Jul 2019 01:30:07 -0400 add design pattern book    Wed, 31 Jul 2019 01:15:01 -0400 add aop, to read    Wed, 31 Jul 2019 00:55:30 -0400 reorder privilege separation in the menu    Wed, 31 Jul 2019 00:52:28 -0400 3 new papers on program partition, to read    Tue, 30 Jul 2019 17:35:10 -0400 typesys in safecode: c lang    Tue, 30 Jul 2019 17:16:22 -0400 2006safecode: typesys: language    Tue, 30 Jul 2019 16:11:37 -0400 questions on type system in dsa; rename questions/propersals to Q\u0026A; XuanTie not Xuantie;    Tue, 30 Jul 2019 12:27:01 -0400 todo: type system in dsa; todo func ptr static check \u0026amp; runtime check in safecode    Tue, 30 Jul 2019 11:10:54 -0400 answer function pointer runtime check in SAFECode    Tue, 30 Jul 2019 10:59:44 -0400 code: line-height 1.6    Tue, 30 Jul 2019 10:46:20 -0400 kernel lang by extending C? golang link    Tue, 30 Jul 2019 00:30:46 -0400 1% userspace code change    Tue, 30 Jul 2019 00:27:01 -0400 answer cheri kernel question: a hybrid kernel in CheriABI    Tue, 30 Jul 2019 00:16:59 -0400 new language arch menu    Tue, 30 Jul 2019 00:05:25 -0400 os in rust link    Mon, 29 Jul 2019 23:51:29 -0400 safecode TR 2005: type inference in dsa by analyzing pointer uses    Mon, 29 Jul 2019 17:47:14 -0400 func pointers    Mon, 29 Jul 2019 16:39:46 -0400 questions on affine transformations    Mon, 29 Jul 2019 16:31:47 -0400 control C    Mon, 29 Jul 2019 12:26:23 -0400 todos    Mon, 29 Jul 2019 12:17:43 -0400 runtime check for array bounds in safecode    Mon, 29 Jul 2019 00:09:16 -0400 update book list    Sun, 28 Jul 2019 23:38:03 -0400 dsa basics from 2005LattnerPhD    Sun, 28 Jul 2019 23:37:21 -0400 use latex in markdown based on MathJax    Sun, 28 Jul 2019 14:40:47 -0400 1997 backwards compatible bound checking by Jones and Kelly; hott in fm;    Fri, 26 Jul 2019 16:04:46 -0400 runtime checks; pingtouge xuantie 910    Fri, 26 Jul 2019 11:07:44 -0400 cfg added    Fri, 26 Jul 2019 10:52:03 -0400 interprocedural in pa     \u0026hellip;\n"
}]